<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Local Random Forest ‚Äî Train on a CSV</title>

  <!-- CSV parsing + charts + zip export -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root{
      --bg0:#070b16;
      --bg1:#0b1226;
      --panel:#0f1833;
      --panel2:#0c1430;
      --text:#eaf0ff;
      --muted:rgba(234,240,255,0.75);
      --muted2:rgba(234,240,255,0.55);
      --border:rgba(234,240,255,0.12);
      --border2:rgba(234,240,255,0.08);
      --primary:#6d28d9;
      --primary2:#8b5cf6;
      --good:#32d583;
      --warn:#fdb022;
      --bad:#f97066;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1000px 550px at 20% 0%, rgba(109,40,217,0.22), transparent 60%),
        radial-gradient(900px 520px at 95% 10%, rgba(139,92,246,0.16), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    .wrap{max-width:1200px;margin:0 auto;padding:18px 16px 60px}
    .topbar{
      position:sticky;top:0;z-index:50;
      background:linear-gradient(180deg, rgba(7,11,22,0.92), rgba(7,11,22,0.72));
      backdrop-filter: blur(14px);
      border-bottom:1px solid var(--border2);
      padding:14px 16px;
      margin: -18px -16px 18px;
    }

    .topline{
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;
      max-width:1200px;margin:0 auto;
    }

    h1{margin:0;font-size:18px;letter-spacing:0.2px}
    .sub{
      margin-top:6px;color:var(--muted);font-size:13px;line-height:1.35;
      max-width:760px;
    }

    .badges{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      padding:7px 10px;border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.03);
      color:var(--muted);font-size:12px;white-space:nowrap;
    }

    .stepper{
      max-width:1200px;margin:14px auto 0;
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
    }
    .step{
      display:flex;align-items:center;gap:10px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--border2);
      background:rgba(255,255,255,0.02);
      color:var(--muted);
      cursor:pointer;
      user-select:none;
      transition:120ms ease;
    }
    .step:hover{transform:translateY(-1px);border-color:rgba(234,240,255,0.16)}
    .step.locked{
      opacity:0.45;
      cursor:not-allowed;
    }
    .step.locked:hover{
      transform:none;
      border-color:rgba(234,240,255,0.12);
    }
    .step .dot{
      width:20px;height:20px;border-radius:50%;
      border:1px solid var(--border);
      display:grid;place-items:center;
      font-size:11px;color:var(--muted);
      background:rgba(255,255,255,0.02);
    }
    .step.active{
      border-color:rgba(139,92,246,0.55);
      background:rgba(139,92,246,0.12);
      color:rgba(234,240,255,0.92);
    }
    .step.active .dot{
      border-color:rgba(139,92,246,0.70);
      color:rgba(234,240,255,0.95);
      background:rgba(139,92,246,0.18);
    }
    .step.done{
      border-color:rgba(50,213,131,0.40);
      background:rgba(50,213,131,0.08);
      color:rgba(50,213,131,0.95);
    }
    .step.done .dot{
      border-color:rgba(50,213,131,0.55);
      color:rgba(50,213,131,0.95);
      background:rgba(50,213,131,0.10);
    }

    .grid{display:grid;grid-template-columns:1fr;gap:14px}
    .grid > * { min-width: 0; }

    .card{
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      box-shadow: var(--shadow);
      border-radius:var(--radius);
      padding:14px;
    }

    .card h2{margin:0 0 10px;font-size:14px;color:rgba(234,240,255,0.92);letter-spacing:0.15px}
    .muted{color:var(--muted);font-size:13px;line-height:1.35}
    .muted2{color:var(--muted2);font-size:12px;line-height:1.35}
    .mono{font-family:var(--mono);font-size:12px;color:rgba(234,240,255,0.86)}

    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .row.space{justify-content:space-between}

    .btn{
      appearance:none;border:1px solid var(--border);
      background:rgba(255,255,255,0.05);
      color:var(--text);
      padding:9px 12px;border-radius:12px;
      cursor:pointer;font-size:13px;
      transition:120ms ease;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,0.07)}
    .btn:disabled{opacity:0.45;cursor:not-allowed;transform:none}
    .btn.primary{
      border-color:rgba(139,92,246,0.65);
      background:rgba(139,92,246,0.18);
    }
    .btn.primary:hover{background:rgba(139,92,246,0.24)}
    .btn.ghost{
      background:transparent;
      border-color:rgba(234,240,255,0.16);
    }
    .btn.danger{
      border-color:rgba(249,112,102,0.60);
      background:rgba(249,112,102,0.12);
    }

    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:5px 9px;border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.03);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .pill.good{border-color:rgba(50,213,131,0.35);background:rgba(50,213,131,0.08);color:rgba(50,213,131,0.95)}
    .pill.warn{border-color:rgba(253,176,34,0.35);background:rgba(253,176,34,0.08);color:rgba(253,176,34,0.95)}
    .pill.bad {border-color:rgba(249,112,102,0.35);background:rgba(249,112,102,0.08);color:rgba(249,112,102,0.95)}
    .hr{height:1px;background:var(--border2);margin:12px 0}

    .drop{
      border:1px dashed rgba(234,240,255,0.22);
      background:rgba(255,255,255,0.03);
      border-radius:14px;
      padding:18px;
      min-height:112px;
      display:grid;place-items:center;
      text-align:center;
      transition:120ms ease;
    }
    .drop.dragover{
      border-color:rgba(139,92,246,0.75);
      background:rgba(139,92,246,0.10);
      transform:translateY(-1px);
    }
    input[type="file"]{display:none}

    /* Scroll containers: vertical + horizontal */
    .scroll{
      overflow: auto;
      border:1px solid var(--border2);
      background:rgba(0,0,0,0.10);
      border-radius:12px;
      max-height:420px;
      -webkit-overflow-scrolling: touch;
    }
    .scroll table{
      width: max-content;
      min-width: 100%;
    }
    .scroll th, .scroll td{
      white-space: nowrap;
    }

    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{border-bottom:1px solid rgba(234,240,255,0.09);padding:7px 8px;text-align:left;vertical-align:top}
    th{
      position:sticky;top:0;z-index:1;
      background:rgba(15,24,51,0.94);
      backdrop-filter: blur(10px);
      color:rgba(234,240,255,0.92);
      font-weight:600;
    }
    tbody tr:nth-child(2n){background:rgba(255,255,255,0.015)}
    tr.groupRow td{
      background: rgba(139,92,246,0.10);
      color: rgba(234,240,255,0.92);
      font-weight: 650;
      border-bottom: 1px solid rgba(139,92,246,0.25);
    }

    #secondaryMatrix{
      position: absolute;
      inset: 0;
      overflow: auto;
      border-radius: 12px;
    }
    table.cm{
      border-collapse: collapse;
      font-size: 12px;
      width: max-content;
      min-width: 100%;
    }
    table.cm th, table.cm td{
      border-bottom: 1px solid rgba(234,240,255,0.09);
      border-right: 1px solid rgba(234,240,255,0.09);
      padding: 6px 8px;
      text-align: right;
      vertical-align: middle;
      white-space: nowrap;
    }
    table.cm th{
      text-align: center;
      background: rgba(15,24,51,0.94);
      position: sticky;
      top: 0;
      z-index: 2;
    }
    table.cm th.stickyCol{
      left: 0;
      z-index: 3;
    }
    table.cm td.stickyCol{
      position: sticky;
      left: 0;
      z-index: 1;
      background: rgba(10,16,34,0.92);
      text-align: left;
      font-weight: 600;
    }
    td.cmCell{
      font-variant-numeric: tabular-nums;
      min-width: 48px;
    }
    td.cmDiag{
      outline: 2px solid rgba(50,213,131,0.55);
      outline-offset: -2px;
    }

    .two{display:grid;grid-template-columns: 1fr 1fr;gap:12px;align-items:start}
    .three{display:grid;grid-template-columns: 1.2fr 0.8fr;gap:12px;align-items:start}
    @media(max-width:980px){.two,.three{grid-template-columns:1fr}}

    .field{display:grid;gap:6px}
    label{color:var(--muted);font-size:12px}
    select,input[type="number"],input[type="text"]{
      width:100%;
      border:1px solid var(--border2);
      background:rgba(255,255,255,0.04);
      color:var(--text);
      padding:9px 10px;border-radius:12px;
      font-size:13px;
      outline:none;
    }

    .kpiGrid{display:grid;grid-template-columns:1.2fr 1fr 1fr;gap:12px}
    @media(max-width:980px){.kpiGrid{grid-template-columns:1fr}}
    .kpi{
      border:1px solid var(--border2);
      background:rgba(255,255,255,0.03);
      border-radius:14px;padding:12px;
    }
    .kpi .big{font-size:22px;font-weight:650;letter-spacing:0.2px;margin-top:6px}
    .kpi .lbl{color:var(--muted);font-size:12px}
    .kpi .small{color:var(--muted);font-size:12px;margin-top:8px}

    .callout{
      border:1px solid rgba(234,240,255,0.14);
      background:rgba(255,255,255,0.03);
      border-radius:14px;padding:10px 12px;
      color:rgba(234,240,255,0.86);
      font-size:12px;line-height:1.35;
    }
    .callout.good{border-color:rgba(50,213,131,0.35);background:rgba(50,213,131,0.08);color:rgba(50,213,131,0.95)}
    .callout.warn{border-color:rgba(253,176,34,0.35);background:rgba(253,176,34,0.08);color:rgba(253,176,34,0.95)}
    .callout.bad{border-color:rgba(249,112,102,0.35);background:rgba(249,112,102,0.08);color:rgba(249,112,102,0.95)}

    .toast{
      display:grid;
      gap:6px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(12,18,38,0.78);
      color:var(--text);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      max-width:360px;
      font-size:13px;
      line-height:1.3;
      opacity:0;
      transform: translateY(6px);
      transition: 160ms ease;
    }
    .toast.show{
      opacity:1;
      transform: translateY(0);
    }
    .toast.good{border-color:rgba(50,213,131,0.45);background:rgba(50,213,131,0.12);color:rgba(50,213,131,0.95)}
    .toast.warn{border-color:rgba(253,176,34,0.45);background:rgba(253,176,34,0.12);color:rgba(253,176,34,0.95)}
    .toast.bad{border-color:rgba(249,112,102,0.45);background:rgba(249,112,102,0.12);color:rgba(249,112,102,0.95)}

    details{
      border:1px solid var(--border2);
      border-radius:14px;
      background:rgba(255,255,255,0.02);
      padding:10px 12px;
    }
    details > summary{
      cursor:pointer;
      color:rgba(234,240,255,0.92);
      font-size:13px;
      user-select:none;
      list-style:none;
    }
    details > summary::-webkit-details-marker{display:none}
    details .muted{margin-top:8px}

    #shiftDetails > summary{
      padding:0;
    }
    #shiftDetails > summary .muted{margin-top:0}
    #shiftDetails[open] > summary{margin-bottom:10px}

    .spinner{
      width:14px;height:14px;border-radius:50%;
      border:2px solid rgba(234,240,255,0.18);
      border-top-color: rgba(139,92,246,0.95);
      display:inline-block;
      animation:spin 0.75s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    pre.code{
      margin:0;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--border2);
      background:rgba(0,0,0,0.25);
      overflow:auto;
      max-height:420px;
      line-height:1.35;
      white-space:pre;
      font-family:var(--mono);
      font-size:12px;
      color:rgba(234,240,255,0.86);
    }

    .hidden{display:none!important}

    /* Chart sizing: prevent runaway growth */
    .two > div, .three > div, .kpiGrid > div { min-width: 0; }
    .chartBox {
      position: relative;
      width: 100%;
      height: 320px;
    }
    .chartBox canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
      max-width: 100% !important;
    }

    /* Sortable header styling */
    th.sortable{
      cursor: pointer;
      user-select: none;
    }
    th.sortable:hover{
      background: rgba(255,255,255,0.03);
    }
    .sort-indicator{
      display: inline-block;
      width: 10px;
      margin-left: 6px;
      color: rgba(234,240,255,0.65);
      font-size: 11px;
    }
    .pickTarget{
      cursor: pointer;
    }
    .pickTarget:hover{
      text-decoration: underline;
    }
    .pickTarget.active{
      font-weight: 750;
      text-decoration: underline;
    }
    #previewTable th.previewPick,
    #previewTable td.previewPick{
      transition: background 120ms ease;
    }
    #previewTable th.previewPick.hoverCol,
    #previewTable td.previewPick.hoverCol{
      background: rgba(139,92,246,0.14);
    }
    #previewTable th.previewPick.selectedCol,
    #previewTable td.previewPick.selectedCol{
      background: rgba(139,92,246,0.22);
    }
    #previewTable th.previewPick{
      cursor: pointer;
    }

    .globalDropOverlay{
      position: fixed;
      inset: 0;
      z-index: 999;
      display: grid;
      place-items: center;
      background: rgba(7,11,22,0.60);
      backdrop-filter: blur(6px);
      pointer-events: none;
    }
    .globalDropOverlay .inner{
      border: 2px dashed rgba(139,92,246,0.70);
      background: rgba(15,24,51,0.65);
      border-radius: 16px;
      padding: 18px 16px;
      width: min(720px, calc(100vw - 36px));
      box-shadow: var(--shadow);
      text-align: center;
    }
    .globalDropOverlay .title{
      font-weight: 700;
      letter-spacing: 0.2px;
      margin-bottom: 6px;
    }
    .globalDropOverlay .hint{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div id="globalDropOverlay" class="globalDropOverlay hidden" aria-hidden="true">
    <div class="inner">
      <div class="title">Drop a CSV to start over</div>
      <div class="hint">You can drop a file anywhere on this page.</div>
    </div>
  </div>
  <div class="topbar">
    <div class="topline">
      <div>
        <h1>Train a Random Forest on a CSV ‚Äî locally</h1>
        <div class="sub">
          Drop a CSV, pick the column you want to predict, and train a strong baseline model. Your CSV data stays in this browser tab ‚Äî the page fetches JS libraries from CDNs unless you self-host.
        </div>
      </div>
      <div class="badges">
        <div class="badge" title="Your CSV data stays in this browser tab. This page loads JS libraries from CDNs unless you self-host.">üîí Data stays local</div>
        <div class="badge" title="Dependencies are fetched from CDNs (PapaParse, Chart.js, JSZip, ml-random-forest via esm.sh). Self-host for offline/airgapped use.">üåê CDN deps</div>
        <div class="badge" id="hwBadge">üß† CPU threads: ?</div>
        <button class="btn danger" id="resetAllBtn">Reset</button>
      </div>
    </div>

    <div class="stepper" id="stepper"></div>
  </div>

  <div class="wrap">
    <div class="grid">

      <!-- STEP 1: UPLOAD -->
      <section class="card" id="panelUpload">
        <h2>Upload</h2>

	        <div class="drop" id="dropZone">
	          <div>
	            <div style="font-weight:650;margin-bottom:6px;">Drop a CSV to start</div>
	            <div class="muted">or <button class="btn" id="browseBtn">Browse‚Ä¶</button> <button class="btn ghost" id="sampleBtn">Use a sample CSV</button></div>
	            <input id="fileInput" type="file" accept=".csv,text/csv" />
	            <div class="muted2" style="margin-top:10px;">First row must be column headers.</div>
	          </div>
	        </div>

        <div id="uploadStatus" class="row" style="margin-top:12px;"></div>

        <div id="uploadSummary" class="hidden" style="margin-top:12px;">
          <div class="row space">
            <div class="row">
              <span class="pill good" id="dsLoadedPill">Loaded</span>
              <span class="pill" id="dsShapePill">‚Äî</span>
              <span class="pill" id="dsPreviewPill">Preview</span>
            </div>
            <button class="btn primary" id="continueToSetupBtn" disabled>Continue</button>
          </div>

          <div class="hr"></div>
          <div class="field" style="margin-bottom:8px;">
            <label for="targetSearch">Search target column</label>
            <input id="targetSearch" type="text" placeholder="Search columns‚Ä¶" />
            <div class="muted2">Type to filter the preview columns below.</div>
          </div>
          <div class="muted2" style="margin-top:10px;">Preview (first 12 rows)</div>
          <div class="scroll" style="margin-top:8px;max-height:320px;">
            <table id="previewTable"></table>
          </div>
        </div>
      </section>

      <!-- STEP 2: SETUP -->
      <section class="card hidden" id="panelSetup">
        <h2>Choose target & confirm setup</h2>

        <div class="three">
          <div>
            <div class="two">
              <div class="field">
                <label for="targetSelect">What do you want to predict?</label>
                <select id="targetSelect"></select>
              </div>
              <div class="field">
                <label for="taskMode">Predict mode</label>
                <select id="taskMode">
                  <option value="auto" selected>Auto (recommended)</option>
                  <option value="regression">Regression</option>
                  <option value="classification">Classification</option>
                </select>
                <div class="row" style="margin-top:6px;">
                  <span class="pill hidden" id="taskModeDetectedPill" title="Based on target column inferred type + sample uniqueness.">‚Äî</span>
                </div>
              </div>
            </div>

            <div class="row" style="margin-top:10px;">
              <span class="pill" id="rowsPill">Rows: ‚Äî</span>
              <span class="pill" id="colsPill">Columns: ‚Äî</span>
              <span class="pill" id="reviewPill">Needs review: ‚Äî</span>
            </div>

            <div class="hr"></div>

            <div class="two">
              <div class="field">
                <label for="maxRows">Max rows (0 = all)</label>
                <input id="maxRows" type="number" min="0" step="1000" value="50000" />
                <div class="muted2">Useful for quick iteration on huge CSVs. For time splits, we take the last N rows (file order).</div>
              </div>

              <div class="field">
                <label for="testFrac">Test fraction</label>
                <input id="testFrac" type="number" value="0.1" />
                <div class="muted2">What fraction [0-1] of the data to use for testing.</div>
              </div>
            </div>

            <div class="two" style="margin-top:10px;">
              <div class="field">
                <label>Split strategy</label>
                <select id="splitStrategy">
                  <option value="random" selected>Random</option>
                </select>
              </div>

              <div class="field">
                <label for="targetTransform">Target transform</label>
                <select id="targetTransform">
                  <option value="none" selected>None</option>
                  <option value="log1p">log1p (for non-negative targets)</option>
                </select>
                <div class="muted2">If enabled, we train on transformed targets and invert predictions back.</div>
              </div>
            </div>

            <div id="timeSplitSettings" class="two hidden" style="margin-top:10px;">
              <div class="field">
                <label for="splitDateCol">Time column</label>
                <select id="splitDateCol"></select>
              </div>

              <div class="field">
                <label for="splitMethod">Validation rule</label>
                <select id="splitMethod">
                  <option value="cutoff" selected>Cutoff date (recommended)</option>
                  <option value="fraction">Test fraction</option>
                </select>
              </div>
            </div>

            <div class="field hidden" id="cutoffField" style="margin-top:10px;">
              <label for="cutoffDate">Cutoff date (train &lt; cutoff, valid ‚â• cutoff)</label>
              <input id="cutoffDate" type="text" placeholder="YYYY-MM-DD" inputmode="numeric" />
            </div>

            <div class="hr"></div>

            <div id="setupCallout" class="callout hidden"></div>

            <details id="advancedTargetDetails" class="hidden" style="margin-top:12px;">
              <summary>Advanced (multi-class target)</summary>
              <div class="hr"></div>

              <div class="muted2" style="margin-bottom:10px;">
                These options are off by default and only apply if enabled.
              </div>

              <div class="callout" id="multiClassSummaryCallout"></div>

              <div class="hr"></div>

              <div class="callout">
                <div style="font-weight:650;margin-bottom:6px;">1) Keep top N classes (map the rest ‚Üí <span class="mono">RARE</span>)</div>
                <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap;">
                  <label class="row" style="gap:8px;align-items:center;margin:0;">
                    <input type="checkbox" id="topNEnable" />
                    <span>Enable</span>
                  </label>
                  <div class="row" style="gap:8px;align-items:center;">
                    <span class="muted2">Keep</span>
                    <input id="topNKeep" type="number" min="1" step="1" value="5" style="width:110px;" />
                    <span class="muted2">most frequent classes</span>
                  </div>
                </div>
                <div class="muted2" id="topNSummary" style="margin-top:8px;">‚Äî</div>
              </div>

              <div class="hr"></div>

	              <div class="callout">
	                <div style="font-weight:650;margin-bottom:6px;">2) Derived boolean target (binary) from a pythonic expression</div>
	                <div class="muted2">
	                  Use <span class="mono" id="derivedTargetValueIdent">target</span> for the target-cell value. Examples:
	                  <span class="mono" id="derivedTargetExprExample1">target in (6,7,8)</span>,
	                  <span class="mono" id="derivedTargetExprExample2">len(target) &gt; 5</span>.
	                </div>
	                <div class="muted2" style="margin-top:6px;">
	                  Assumptions: the value is converted to a trimmed string; comparisons (<span class="mono">&lt;</span>, <span class="mono">&gt;=</span>, etc.) use numeric compare only if both sides parse as numbers, otherwise string compare; <span class="mono">in (...) </span> / <span class="mono">not in (...) </span> accept only literal lists (numbers/strings/true/false/none). No regex, arithmetic, or access to other columns.
	                </div>

                <div class="two" style="margin-top:10px;">
                  <div class="field" style="margin:0;">
                    <label for="derivedTargetColName">New column name</label>
                    <input id="derivedTargetColName" type="text" placeholder="e.g. is_positive" />
                  </div>
                  <div class="field" style="margin:0;">
                    <label for="derivedTargetExpr">Expression</label>
	                    <input id="derivedTargetExpr" type="text" placeholder='e.g. target in (6,7,8) or len(target) > 5' />
	                  </div>
	                </div>

                <div class="row" style="margin-top:10px;">
                  <button class="btn primary" id="applyDerivedTargetBtn">Create column + use as target</button>
                  <button class="btn ghost" id="undoDerivedTargetBtn">Undo</button>
                </div>

                <div class="muted2" id="derivedTargetStatus" style="margin-top:8px;">‚Äî</div>
              </div>
            </details>

            <div class="row space" style="margin-top:12px;">
              <button class="btn" id="backToUploadBtn">Back</button>
              <button class="btn primary" id="continueToTrainBtn" disabled>Continue</button>
            </div>
          </div>

          <div>
            <details id="reviewDetails" open>
              <summary>Review columns</summary>
              <div class="hr"></div>

              <div style="margin-bottom:10px;">
                <div class="field">
                  <label for="maxCard">max_card (cat vs cont threshold)</label>
                  <input id="maxCard" type="number" min="1" step="1" value="50" />
                  <div class="muted2">If an integer column has ‚â§ max_card unique values, treat it as categorical.</div>
                </div>
              </div>

              <div class="scroll" style="max-height:420px;">
                <table id="reviewColumnsTable">
                  <thead>
                    <tr>
                      <th class="sortable" data-sort="include">Use <span class="sort-indicator"></span></th>
                      <th class="sortable" data-sort="name">Column <span class="sort-indicator"></span></th>
                      <th class="sortable" data-sort="type">Type <span class="sort-indicator"></span></th>
                      <th class="sortable" data-sort="missing">Missing% <span class="sort-indicator"></span></th>
                      <th class="sortable" data-sort="unique">Unique (sample) <span class="sort-indicator"></span></th>
                      <th class="sortable" data-sort="flags">Flags <span class="sort-indicator"></span></th>
                      <th class="sortable" data-sort="examples">Examples <span class="sort-indicator"></span></th>
                    </tr>
                  </thead>
                  <tbody id="colConfigBody"></tbody>
                </table>
              </div>
            </details>
          </div>
        </div>
      </section>

      <!-- STEP 3: TRAIN -->
      <section class="card hidden" id="panelTrain">
        <h2>Train</h2>

        <div class="muted" style="margin-bottom:10px;">
          Defaults are tuned for a solid baseline. Adjust if you want faster iteration or more thorough training.
        </div>

        <div class="row" id="trainChips" style="margin-bottom:10px;"></div>

        <details id="advancedTrainDetails" style="margin-top:12px;" open>
          <summary>Settings</summary>
          <div class="hr"></div>

          <div class="two">
            <div class="field">
              <label for="seed">Random seed</label>
              <input id="seed" type="number" value="42" />
            </div>
            <div class="field">
              <label for="replacement">Feature sampling replacement</label>
              <select id="replacement">
                <option value="false" selected>false</option>
                <option value="true">true</option>
              </select>
            </div>
          </div>

          <div class="two" style="margin-top:10px;">
            <div class="field">
              <label for="nEstimators">Trees</label>
              <input id="nEstimators" type="number" min="10" step="10" value="100" />
            </div>
            <div class="field">
              <label for="maxFeatures">maxFeatures</label>
              <input id="maxFeatures" type="text" value="1.0" placeholder="e.g. sqrt, log2, 0.33, or 12" />
            </div>
          </div>

          <div class="two" style="margin-top:10px;">
            <div class="field">
              <label for="maxDepth">maxDepth</label>
              <input id="maxDepth" type="number" min="1" step="1" value="20" placeholder="blank = unlimited" />
            </div>
            <div class="field">
              <label for="minNumSamples">minNumSamples</label>
              <input id="minNumSamples" type="number" min="1" step="1" value="10" placeholder="blank = 1" />
            </div>
          </div>

          <div class="muted2" style="margin-top:10px;">
            Defaults follow common best practice for tabular baselines: enough trees, feature subsampling, row bagging, and mild tree limits for speed.
          </div>
        </details>

        <div class="hr"></div>

        <div class="row space">
          <button class="btn" id="backToSetupBtn">Back</button>
          <div class="row">
            <div id="trainStatus" class="muted2"></div>
            <button class="btn danger" id="stopBtn" disabled>Stop</button>
            <button class="btn primary" id="trainBtn" disabled>Train model</button>
          </div>
        </div>
      </section>

      <!-- STEP 4: RESULTS -->
      <section class="card hidden" id="panelResults">
        <h2>Results</h2>

        <div class="kpiGrid">
          <div class="kpi">
            <div class="lbl" id="primaryMetricLabel">‚Äî</div>
            <div class="big mono" id="primaryMetricValue">‚Äî</div>
            <div class="small" id="primaryMetricSub">‚Äî</div>
          </div>

          <div class="kpi">
            <div class="lbl">Setup</div>
            <div class="small mono" id="setupSummary">‚Äî</div>
            <div class="small mono" id="featureSummary">‚Äî</div>
          </div>

          <div class="kpi">
            <div class="lbl">Next</div>
            <div class="small">Export a portable artifact (model + preprocessing + sample loader).</div>
            <div class="row" style="margin-top:10px;">
              <button class="btn primary" id="jumpToExportBtn">Export</button>
              <button class="btn" id="backToTrainBtn">Back</button>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <div id="resultsCallouts" class="grid" style="gap:10px;"></div>

        <div class="hr"></div>

        <div class="two">
          <div>
            <div class="row space" style="margin-bottom:8px;">
              <div class="muted">What matters (feature importance)</div>
              <div class="row">
                <select id="importanceMode" style="width:220px;">
                  <option value="base" selected>Aggregate by column</option>
                  <option value="derived">Show derived features</option>
                </select>
              </div>
            </div>
            <div class="chartBox">
              <canvas id="fiChart"></canvas>
            </div>
            <div class="muted2" style="margin-top:8px;">
              Aggregation groups derived features (e.g. date parts + missing indicators) back to their original column.
            </div>
            <div class="row hidden" id="pruneImpRow" style="margin-top:10px;">
              <button class="btn" id="pruneImpBtn">Prune low-importance ‚Üí retrain</button>
              <div class="field" style="margin:0;min-width:160px;">
                <label for="pruneMinImp" style="margin-bottom:4px;">Min importance</label>
                <input id="pruneMinImp" type="number" min="0" step="0.001" value="0.002" style="width:160px;" />
                <div class="muted2" style="margin-top:4px;">Drops columns below this fraction</div>
              </div>
              <button class="btn ghost" id="pruneUndoBtn" disabled>Undo prune</button>
              <span class="muted2" id="pruneMiniHint">‚Äî</span>
            </div>
          </div>

          <div>
            <div class="row space" style="margin-bottom:8px;">
              <div class="muted" id="secondaryChartTitle">‚Äî</div>
              <div class="row">
                <span class="pill" id="secondaryChartPill">‚Äî</span>
              </div>
            </div>
            <div class="row hidden" id="classFocusRow" style="margin-bottom:8px;">
              <select id="classFocus" style="width:260px;"></select>
              <div class="muted2" id="classMetrics">‚Äî</div>
            </div>
            <div class="chartBox">
              <canvas id="secondaryChart"></canvas>
              <div id="secondaryMatrix" class="hidden"></div>
            </div>
            <div class="muted2" style="margin-top:8px;" id="secondaryChartHint">‚Äî</div>
          </div>
        </div>

        <div class="hr"></div>

        <details id="shiftDetails">
          <summary>
            <div class="row space">
              <div class="muted">Shift detector (is_valid model)</div>
              <span class="pill" id="shiftPill">‚Äî</span>
            </div>
          </summary>
          <div class="two" style="margin-top:10px;">
            <div class="callout">
              <div style="font-weight:650;margin-bottom:6px;">How to read this</div>
              <div class="muted2" id="shiftSummary">‚Äî</div>
            </div>
            <div>
              <div class="row space" style="margin-bottom:8px;margin-top:0;">
                <div class="muted">Top shift drivers (feature importance)</div>
                <button class="btn" id="pruneShiftTopBtn" disabled>Prune top shift driver ‚Üí retrain</button>
              </div>
              <div class="chartBox">
                <canvas id="shiftFiChart"></canvas>
              </div>
            </div>
          </div>
        </details>

        <div class="hr"></div>

        <div class="row space" style="margin-bottom:8px;">
          <div class="muted">Predictions explorer</div>
          <div class="row">
            <span class="pill" id="uncertaintyPill">Uncertainty: ‚Äî</span>
            <input id="predTopK" type="number" min="10" step="10" value="30" style="width:90px;" />
            <button class="btn" id="downloadPredCsvBtn">Download predictions CSV</button>
          </div>
        </div>

        <details id="predInsightsDetails">
          <summary>
            <div class="row space">
              <div class="muted2">Prediction diagnostics (errors + uncertainty)</div>
              <span class="pill">What am I looking at?</span>
            </div>
          </summary>

          <div class="callout" style="margin-top:10px;">
            <div style="font-weight:650;margin-bottom:6px;">What this section is</div>
            <div class="muted2">
              These views help you understand <span class="mono">which rows</span> the model struggles with, and <span class="mono">whether it knew it was struggling</span>.
              Everything here is computed on the <span class="mono">test split</span> only (rows the model did not train on).
            </div>
          </div>

          <div class="two" style="margin-top:10px;">
            <div>
              <div class="muted2" style="margin-bottom:6px;">Worst errors (top-k)</div>
              <div class="muted2" style="margin:0 0 8px;">
                Rows where the prediction was most wrong. Use this to spot data quality issues (missing values, strange units, parsing mistakes),
                or segments the model can‚Äôt learn from the available features.
              </div>
              <div class="scroll">
                <table id="worstErrTable"></table>
              </div>
              <div class="muted2" style="margin-top:8px;">
                Tip: open ‚ÄúFull predictions table‚Äù below to see more raw columns for any suspicious row.
              </div>
            </div>
            <div>
              <div class="muted2" style="margin-bottom:6px;">Highest uncertainty (top-k)</div>
              <div class="muted2" style="margin:0 0 8px;">
                ‚ÄúUncertainty‚Äù here means <span class="mono">tree disagreement</span> (fastai-style).
                A Random Forest is many trees voting; if they don‚Äôt agree, the model is less confident for that row.
              </div>
              <div class="scroll">
                <table id="highUncTable"></table>
              </div>
              <div class="muted2" style="margin-top:8px;">
                Not all uncertainty is bad: a row can be uncertain but still correct. The scatter below helps separate ‚Äúuncertain‚Äù from ‚Äúwrong‚Äù.
              </div>
            </div>
          </div>

          <div class="hr"></div>

          <div class="row space" style="margin-bottom:8px;">
            <div class="muted2">Abs(error) vs uncertainty</div>
            <div class="row">
              <span class="pill" id="errUncPill">‚Äî</span>
            </div>
          </div>
          <div class="chartBox">
            <canvas id="errUncChart"></canvas>
          </div>
          <div class="muted2" style="margin-top:8px;">
            How to read this: <span class="mono">right</span> = more wrong, <span class="mono">up</span> = less consensus across trees.
            Upper-right often indicates shift or rare edge-cases. Bottom-right can mean ‚Äúconfidently wrong‚Äù (often leakage, label noise, or a missing important feature).
          </div>
        </details>

        <div class="hr"></div>

        <details id="predFullDetails">
          <summary>
            <div class="row space">
              <div class="muted2">Full predictions table (paged)</div>
              <span class="pill">Filter + paging</span>
            </div>
          </summary>
          <div class="row" style="margin-top:10px;">
            <input id="predFilter" type="text" placeholder="Filter (true/pred contains‚Ä¶)" style="width:260px;" />
            <input id="pageSize" type="number" min="10" step="10" value="50" style="width:90px;" />
            <button class="btn" id="prevPage">Prev</button>
            <button class="btn" id="nextPage">Next</button>
          </div>
          <div class="scroll" style="margin-top:10px;">
            <table id="predTable"></table>
          </div>
          <div class="muted2" style="margin-top:10px;">
            This table shows raw input rows from your CSV (test split) alongside predictions, errors, and uncertainty (tree disagreement).
          </div>
        </details>

        <div class="muted2" style="margin-top:10px;">
          Tree-disagreement uncertainty is a fastai-style confidence signal: higher values mean the trees disagree more.
        </div>
      </section>

      <!-- STEP 5: EXPORT -->
      <section class="card hidden" id="panelExport">
        <h2>Export</h2>

        <div class="row space">
          <div class="row">
            <span class="pill" id="artifactPill">Artifact: not ready</span>
            <span class="pill" id="artifactDetailPill">‚Äî</span>
          </div>
          <div class="row">
            <button class="btn" id="backToResultsBtn">Back</button>
            <button class="btn primary" id="downloadZipBtn" disabled>Download rf_artifact.zip</button>
          </div>
        </div>

        <div class="hr"></div>

        <div class="muted" style="margin-bottom:8px;">Sample loader</div>
        <pre class="code" id="sampleCode"></pre>

        <div class="hr"></div>
        <div class="callout">
          <div style="font-weight:650;margin-bottom:6px;">Note on opening locally</div>
          <div class="muted2">
            Some browsers restrict ES module imports when opening HTML via <span class="mono">file://</span>.
            If you see import/CORS errors, run a tiny local server (e.g. <span class="mono">python -m http.server</span>) and open <span class="mono">http://localhost:8000</span>.
          </div>
        </div>
      </section>

    </div>
  </div>

  <div id="toastHost" style="position:fixed;right:14px;bottom:14px;z-index:1000;display:grid;gap:10px;"></div>

  <script type="module">
    import { RandomForestRegression, RandomForestClassifier } from "https://esm.sh/ml-random-forest@2.1.0";
    import { DecisionTreeClassifier, DecisionTreeRegression } from "https://esm.sh/ml-cart@^2.1.1?target=es2022";
    import { Matrix, MatrixColumnSelectionView, MatrixRowSelectionView } from "https://esm.sh/ml-matrix@^6.8.2?target=es2022";
    import { MersenneTwister19937, integer } from "https://esm.sh/random-js@^2.1.0?target=es2022";

    // ----------------------------
    // State
    // ----------------------------
    const STEPS = [
      { key: "upload",  title: "Upload" },
      { key: "setup",   title: "Target" },
      { key: "train",   title: "Train" },
      { key: "results", title: "Results" },
      { key: "export",  title: "Export" },
    ];

    let APP = {
      step: 0,
      raw: {
        fileName: null,
        rows: [],
        columns: [],
        colMeta: {}, // {col: {inferredType, missingFrac, uniqueSample, examples[], flags:{idLike,idByName}, include:true}}
        targetCol: null
      },
      setup: {
        splitDateCol: null,
        splitMethod: "cutoff",
        cutoffDate: "",
        splitStrategy: "random",
        testFrac: 0.1,
        taskMode: "auto",
        targetTransform: "none",
        maxRows: 50000,
        maxCard: 50,
        forceDate: "",
        forceCat: "",
        forceCont: "",
        excludeCols: "",
        excluded: new Set(),
        forcedTypes: {
          date: new Set(),
          categorical: new Set(),
          continuous: new Set(),
        },
        multiClass: {
          topN: {
            enabled: false,
            keep: 5,
            rareLabel: "RARE",
          },
          derivedTarget: {
            enabled: false,
            sourceCol: null,
            derivedCol: "",
            expr: "",
            lastStatus: "",
            lastError: "",
          },
        },
      },
      train: {
        rfOptions: null,
        model: null,
        pipeline: null,
        featureNames: [],
        baseForDerived: [],
        derivedTypeByFeature: null,
        split: { trainIdx: [], testIdx: [] },
        yTrain: [],
        yTest: [],
        yPred: [],
        yPredLabel: [],
        err: [],
        absErr: [],
        uncertainty: null,
        uncertaintyDetails: null,
        uncertaintyStatus: "none",
        uncertaintyError: "",
        runSummary: null,
        oobPred: null,
        testRowRefs: [],
        fiDerived: [],
        fiBase: [],
        shift: null,
        dropped: { unusableTargetRows: 0, unseenTestLabels: 0, sampledRows: 0, usableRows: 0 }
      },
      ui: {
        charts: {
          fi: null,
          secondary: null,
          shift: null,
          errUnc: null,
        },
        training: {
          startMs: 0,
          totalUnits: 0,
          completedUnits: 0,
          isTraining: false,
          stopRequested: false,
          abortController: null,
          diagAbortController: null,
          runSeq: 0,
        },
        parseSeq: 0,
        predPage: 0,
        predFilter: "",
        previewFilter: "",
        colSort: { key: "name", dir: "asc" },
        maxUnlockedStep: 0,
        shiftAutoExpandedRunSeq: 0,
        prevRunSummary: null,
        pruneUndoExcluded: null,
        pruneUndoReason: "",
        pruneJustApplied: false,
      }
    };

    // ----------------------------
    // DOM helpers
    // ----------------------------
    const $ = (id) => document.getElementById(id);
    const show = (el) => el.classList.remove("hidden");
    const hide = (el) => el.classList.add("hidden");

    function showToast(message, kind = "") {
      const host = $("toastHost");
      if (!host) return;
      const toast = document.createElement("div");
      toast.className = `toast ${kind}`.trim();
      toast.textContent = message;
      host.appendChild(toast);
      requestAnimationFrame(() => toast.classList.add("show"));
      const dismiss = () => {
        toast.classList.remove("show");
        toast.addEventListener("transitionend", () => toast.remove(), { once: true });
        setTimeout(() => toast.remove(), 220);
      };
      setTimeout(dismiss, 3000);
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function truncate(s, maxLen = 200) {
      const t = (s === null || s === undefined) ? "" : String(s);
      if (t.length <= maxLen) return t;
      return t.slice(0, Math.max(0, maxLen - 1)) + "‚Ä¶";
    }

    // ----------------------------
    // Core utils
    // ----------------------------
    function normStr(v) {
      if (v === null || v === undefined) return "";
      return String(v).trim();
    }

    function parseNum(v) {
      const s = normStr(v);
      if (!s) return NaN;
      const x = Number(s);
      return Number.isFinite(x) ? x : NaN;
    }

    function looksLikeDateString(s) {
      const t = s.trim();
      if (!t) return false;
      if (!(/[\/\-T:]/.test(t))) return false;
      const p1 = /^\d{4}[-\/]\d{1,2}[-\/]\d{1,2}(\b|T)/;
      const p2 = /^\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}(\b|T)/;
      const p3 = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
      return p1.test(t) || p2.test(t) || p3.test(t);
    }

    function parseDate(v) {
      const s = normStr(v);
      if (!s) return null;
      if (!looksLikeDateString(s)) return null;
      const d = new Date(s);
      if (Number.isNaN(d.getTime())) return null;
      return d;
    }

    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let x = t;
        x = Math.imul(x ^ (x >>> 15), x | 1);
        x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function shuffleInPlace(arr, rng) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function median(values) {
      const a = values.filter(Number.isFinite);
      const n = a.length;
      if (!n) return 0;
      a.sort((x,y)=>x-y);
      const m = Math.floor(n/2);
      return (n%2) ? a[m] : (a[m-1] + a[m]) / 2;
    }

    function isoWeekNumber(d) {
      const dt = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
      const dayNum = dt.getUTCDay() || 7;
      dt.setUTCDate(dt.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(dt.getUTCFullYear(), 0, 1));
      return Math.ceil((((dt - yearStart) / 86400000) + 1) / 7);
    }

    function dateParts(d) {
      const year = d.getFullYear();
      const month = d.getMonth() + 1;
      const week = isoWeekNumber(d);
      const day = d.getDate();
      const dow = d.getDay();
      const start = new Date(d.getFullYear(), 0, 1);
      const dayOfYear = Math.floor((d - start) / 86400000) + 1;

      const isMonthStart = day === 1;
      const isMonthEnd = new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate() === day;

      const qStartMonths = new Set([1, 4, 7, 10]);
      const qEndMonths = new Set([3, 6, 9, 12]);
      const isQuarterStart = qStartMonths.has(month) && isMonthStart;
      const isQuarterEnd = qEndMonths.has(month) && isMonthEnd;

      const isYearStart = (month === 1 && day === 1);
      const isYearEnd = (month === 12 && day === 31);

      return {
        year, month, week, day,
        dayofweek: dow,
        dayofyear: dayOfYear,
        is_month_end: isMonthEnd ? 1 : 0,
        is_month_start: isMonthStart ? 1 : 0,
        is_quarter_end: isQuarterEnd ? 1 : 0,
        is_quarter_start: isQuarterStart ? 1 : 0,
        is_year_end: isYearEnd ? 1 : 0,
        is_year_start: isYearStart ? 1 : 0,
        elapsed: d.getTime()
      };
    }

    function rmse(yTrue, yPred) {
      let s = 0;
      const n = yTrue.length;
      for (let i = 0; i < n; i++) {
        const e = (yPred[i] - yTrue[i]);
        s += e * e;
      }
      return Math.sqrt(s / Math.max(1, n));
    }

    function mae(yTrue, yPred) {
      let s = 0;
      const n = yTrue.length;
      for (let i = 0; i < n; i++) s += Math.abs(yPred[i] - yTrue[i]);
      return s / Math.max(1, n);
    }

    function r2(yTrue, yPred) {
      const n = yTrue.length;
      if (!n) return NaN;
      let mean = 0;
      for (let i = 0; i < n; i++) mean += yTrue[i];
      mean /= n;

      let ssTot = 0;
      let ssRes = 0;
      for (let i = 0; i < n; i++) {
        const dt = yTrue[i] - mean;
        ssTot += dt * dt;
        const dr = yTrue[i] - yPred[i];
        ssRes += dr * dr;
      }
      return 1 - (ssRes / Math.max(1e-12, ssTot));
    }

    function rmsle(yTrue, yPred) {
      for (let i = 0; i < yTrue.length; i++) {
        if (yTrue[i] < 0 || yPred[i] < 0) return null;
      }
      let s = 0;
      const n = yTrue.length;
      for (let i = 0; i < n; i++) {
        const a = Math.log1p(yTrue[i]);
        const b = Math.log1p(yPred[i]);
        const e = a - b;
        s += e * e;
      }
      return Math.sqrt(s / Math.max(1, n));
    }

    function accuracy(yTrue, yPred) {
      let ok = 0;
      for (let i = 0; i < yTrue.length; i++) if (yTrue[i] === yPred[i]) ok++;
      return ok / Math.max(1, yTrue.length);
    }

    function balancedAccuracy(yTrue, yPred, numClasses) {
      const k = Math.max(2, Math.floor(numClasses || 2));
      const tp = new Array(k).fill(0);
      const fn = new Array(k).fill(0);
      for (let i = 0; i < yTrue.length; i++) {
        const t = yTrue[i];
        const p = yPred[i];
        if (t === p) tp[t]++;
        else fn[t]++;
      }
      let recallSum = 0;
      for (let c = 0; c < k; c++) {
        const denom = tp[c] + fn[c];
        const recall = denom ? (tp[c] / denom) : 0;
        recallSum += recall;
      }
      return recallSum / Math.max(1, k);
    }

    function filterPaired(yTrue, yPred) {
      const yt = [];
      const yp = [];
      for (let i = 0; i < Math.min(yTrue.length, yPred.length); i++) {
        const p = yPred[i];
        if (p === null || p === undefined || !Number.isFinite(Number(p))) continue;
        yt.push(yTrue[i]);
        yp.push(p);
      }
      return { yTrue: yt, yPred: yp };
    }

    function f1Macro(yTrue, yPred, numClasses) {
      const tp = new Array(numClasses).fill(0);
      const fp = new Array(numClasses).fill(0);
      const fn = new Array(numClasses).fill(0);

      for (let i = 0; i < yTrue.length; i++) {
        const t = yTrue[i];
        const p = yPred[i];
        if (t === p) tp[t]++;
        else { fp[p]++; fn[t]++; }
      }

      let f1Sum = 0;
      for (let c = 0; c < numClasses; c++) {
        const precision = tp[c] / Math.max(1, (tp[c] + fp[c]));
        const recall = tp[c] / Math.max(1, (tp[c] + fn[c]));
        const f1 = (precision + recall) ? (2 * precision * recall) / (precision + recall) : 0;
        f1Sum += f1;
      }
      return f1Sum / Math.max(1, numClasses);
    }

    function formatNum(x, digits = 6) {
      if (x === null || x === undefined) return "‚Äî";
      if (!Number.isFinite(x)) return String(x);
      return x.toFixed(digits);
    }

    function formatDuration(ms) {
      if (!Number.isFinite(ms) || ms < 0) return "‚Äî";
      if (ms < 10_000) return `${(ms / 1000).toFixed(1)}s`;
      if (ms < 60_000) return `${Math.round(ms / 1000)}s`;
      const s = Math.round(ms / 1000);
      const m = Math.floor(s / 60);
      const rs = s % 60;
      if (m < 60) return `${m}m ${rs}s`;
      const h = Math.floor(m / 60);
      const rm = m % 60;
      return `${h}h ${rm}m`;
    }

    function isAbortError(e) {
      if (!e) return false;
      if (e.name === "AbortError") return true;
      const msg = String(e?.message || "");
      return msg.toLowerCase().includes("abort");
    }

    function setTrainingUi(isTraining) {
      APP.ui.training.isTraining = Boolean(isTraining);
      const canTrain = Boolean(APP.raw.targetCol) && !APP.ui.training.isTraining;
      $("trainBtn").disabled = !canTrain;
      $("stopBtn").disabled = !APP.ui.training.isTraining;
    }

    function requestStopTraining() {
      if (!APP.ui.training.isTraining) return;
      if (APP.ui.training.stopRequested) return;
      APP.ui.training.stopRequested = true;
      try { APP.ui.training.abortController?.abort(); } catch {}
      $("stopBtn").disabled = true;
      $("trainStatus").innerHTML =
        `<span class="spinner"></span> Stopping‚Ä¶ <span class="muted2">Will stop after the current tree finishes, then score a partial model.</span>`;
    }

    function releaseAllResources() {
      try { APP.ui.training.abortController?.abort(); } catch {}
      try { APP.ui.training.diagAbortController?.abort(); } catch {}
      APP.ui.training.abortController = null;
      APP.ui.training.diagAbortController = null;
      APP.ui.training.isTraining = false;
      APP.ui.training.stopRequested = false;

      APP.raw.rows = [];
      APP.train.model = null;
      APP.train.pipeline = null;
      APP.train.featureNames = [];
      APP.train.baseForDerived = [];
      APP.train.derivedTypeByFeature = null;
      APP.train.yTrain = [];
      APP.train.yTest = [];
      APP.train.yPred = [];
      APP.train.yPredLabel = [];
      APP.train.err = [];
      APP.train.absErr = [];
      APP.train.uncertainty = null;
      APP.train.uncertaintyDetails = null;
      APP.train.uncertaintyStatus = "none";
      APP.train.uncertaintyError = "";
      APP.train.runSummary = null;
      APP.train.oobPred = null;
      APP.train.testRowRefs = [];
      APP.train.fiDerived = [];
      APP.train.fiBase = [];
      APP.train.shift = null;

      APP.ui.charts.fi = destroyChart(APP.ui.charts.fi);
      APP.ui.charts.secondary = destroyChart(APP.ui.charts.secondary);
      APP.ui.charts.shift = destroyChart(APP.ui.charts.shift);
      APP.ui.charts.errUnc = destroyChart(APP.ui.charts.errUnc);
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    // Prevent CSV injection when opened in spreadsheet tools
    function sanitizeCsvValue(v) {
      const s = (v === null || v === undefined) ? "" : String(v);
      if (!s) return s;
      if (/^[=+\-@]/.test(s) || /^\t/.test(s)) return "'" + s;
      return s;
    }

    function csvCell(v) {
      const s = sanitizeCsvValue(v);
      return `"${String(s).replaceAll('"','""')}"`;
    }

    // ----------------------------
    // Stepper
    // ----------------------------
    function renderStepper() {
      const s = $("stepper");
      s.innerHTML = STEPS.map((st, i) => {
        const isLocked = i > (APP.ui.maxUnlockedStep || 0);
        const cls = [
          "step",
          i === APP.step ? "active" : "",
          i < APP.step ? "done" : "",
          isLocked ? "locked" : "",
        ].filter(Boolean).join(" ");
        const dot = (i < APP.step) ? "‚úì" : String(i + 1);
        return `<div class="${cls}" data-step="${i}">
          <div class="dot">${dot}</div>
          <div style="font-size:12px;">${escapeHtml(st.title)}</div>
        </div>`;
      }).join("");

      s.querySelectorAll("[data-step]").forEach(el => {
        el.addEventListener("click", () => {
          const i = Number(el.getAttribute("data-step"));
          if (!Number.isFinite(i)) return;
          if (i > (APP.ui.maxUnlockedStep || 0)) {
            showToast("Complete the previous step first.", "warn");
            return;
          }
          gotoStep(i);
        });
      });
    }

    function gotoStep(i) {
      const clamped = Math.max(0, Math.min(STEPS.length - 1, i));
      APP.step = clamped;
      renderStepper();
      window.scrollTo({ top: 0, behavior: "smooth" });

      const panels = {
        0: $("panelUpload"),
        1: $("panelSetup"),
        2: $("panelTrain"),
        3: $("panelResults"),
        4: $("panelExport"),
      };

      Object.entries(panels).forEach(([k, el]) => {
        if (Number(k) === APP.step) show(el);
        else hide(el);
      });

      syncButtons();
    }

    // ----------------------------
    // Inference + metadata
    // ----------------------------
    function inferColumnType(col, rows, { maxCard, forceType } = {}) {
      const maxN = Math.min(rows.length, 2000);
      let nonEmpty = 0, numeric = 0, integerish = 0, dateish = 0;
      const uniq = new Set();
      const examples = [];

      for (let i = 0; i < maxN; i++) {
        const s = normStr(rows[i][col]);
        if (!s) continue;
        nonEmpty++;

        if (examples.length < 4 && !examples.includes(s)) examples.push(s);
        uniq.add(s);

        const x = parseNum(s);
        if (Number.isFinite(x)) {
          numeric++;
          if (Number.isInteger(x)) integerish++;
        } else {
          const d = parseDate(s);
          if (d) dateish++;
        }
      }

      const missingFrac = maxN ? (1 - (nonEmpty / maxN)) : 0;
      const uniqueSample = uniq.size;

      const fracNum = nonEmpty ? (numeric / nonEmpty) : 0;
      const fracDate = nonEmpty ? (dateish / nonEmpty) : 0;
      const fracInt = numeric ? (integerish / numeric) : 0;

      let inferred;
      if (fracDate >= 0.85 && fracNum < 0.40) inferred = "date";
      else if (fracNum >= 0.92) {
        const maxCardValue = Math.max(1, Math.floor(Number(maxCard) || 50));
        const isIntish = (fracInt >= 0.98);
        inferred = (isIntish && uniqueSample <= maxCardValue) ? "categorical" : "continuous";
      } else {
        inferred = "categorical";
      }

      const name = col.toLowerCase();
      const idByName = (name === "id") || name.endsWith("id") || name.includes("_id") || name.includes(" id") || name.includes("identifier");
      const uniqueRatio = nonEmpty ? (uniqueSample / nonEmpty) : 0;

      const idLike = idByName || (inferred !== "date" && fracInt >= 0.95 && uniqueRatio >= 0.95 && uniqueSample >= 50);

      const forced = forceType || null;
      if (forced === "date" || forced === "categorical" || forced === "continuous") inferred = forced;

      return {
        inferredType: inferred,
        missingFrac,
        uniqueSample,
        examples,
        flags: {
          idLike,
          idByName
        },
        include: true
      };
    }

    function setTargetFromPicker(col, { advanceStep = true } = {}) {
      if (!col) return;
      APP.raw.targetCol = col;
      APP.setup.excluded.delete(col);
      renderTargetSelect();
      $("targetSelect").value = col;
      $("targetSelect").dispatchEvent(new Event("change"));

      if (advanceStep) {
        $("uploadStatus").innerHTML =
          `<span class="pill good">Target selected</span><span class="muted2">Proceed to configure split & training.</span>`;
        APP.ui.maxUnlockedStep = Math.max(APP.ui.maxUnlockedStep || 0, 2);
        renderStepper();
        gotoStep(1);
      }
    }

    // ----------------------------
    // Rendering: Upload preview
    // ----------------------------
    function renderPreviewTable(rows, columns) {
      const filter = normStr(APP.ui.previewFilter).toLowerCase();
      const cols = filter
        ? columns.filter(c => c.toLowerCase().includes(filter))
        : columns.slice();
      if (!cols.length) {
        $("previewTable").innerHTML =
          `<tbody><tr><td class="muted2">No columns match the search.</td></tr></tbody>`;
        return;
      }

      const head = "<thead><tr>" + cols.map((c, i) => (
        `<th class="previewPick" data-preview-col="${escapeHtml(c)}" data-preview-idx="${i}">${escapeHtml(c)}</th>`
      )).join("") + "</tr></thead>";
      const body = rows.slice(0, 12).map(r => {
        const tds = cols.map((c, i) => {
          const full = normStr(r[c]) || "";
          const clipped = truncate(full, 200);
          return `<td class="previewPick" data-preview-col="${escapeHtml(c)}" data-preview-idx="${i}" title="${escapeHtml(clipped)}">${escapeHtml(clipped)}</td>`;
        }).join("");
        return `<tr>${tds}</tr>`;
      }).join("");
      $("previewTable").innerHTML = head + `<tbody>${body}</tbody>`;
    }

    function setPreviewColClass(idx, cls, enabled) {
      const root = $("previewTable");
      if (!root) return;
      root.querySelectorAll(`[data-preview-idx="${idx}"]`).forEach(el => {
        el.classList.toggle(cls, Boolean(enabled));
      });
    }

    function bindPreviewTargetPicker() {
      const table = $("previewTable");
      if (!table) return;
      if (table.dataset.boundTargetPicker === "1") return;
      table.dataset.boundTargetPicker = "1";

      let hoverIdx = null;
      let selectedIdx = null;

      const clearHover = () => {
        if (hoverIdx === null) return;
        setPreviewColClass(hoverIdx, "hoverCol", false);
        hoverIdx = null;
      };

      const setHover = (idx) => {
        if (hoverIdx === idx) return;
        clearHover();
        hoverIdx = idx;
        setPreviewColClass(hoverIdx, "hoverCol", true);
      };

      const setSelected = (idx) => {
        if (selectedIdx !== null) setPreviewColClass(selectedIdx, "selectedCol", false);
        selectedIdx = idx;
        if (selectedIdx !== null) setPreviewColClass(selectedIdx, "selectedCol", true);
      };

      table.addEventListener("mousemove", (e) => {
        const cell = e.target.closest("[data-preview-idx]");
        if (!cell) return;
        const idx = Number(cell.getAttribute("data-preview-idx"));
        if (!Number.isFinite(idx)) return;
        setHover(idx);
      });

      table.addEventListener("mouseleave", clearHover);

      table.addEventListener("click", (e) => {
        const cell = e.target.closest("[data-preview-col][data-preview-idx]");
        if (!cell) return;
        const col = cell.getAttribute("data-preview-col");
        const idx = Number(cell.getAttribute("data-preview-idx"));
        if (!col) return;
        if (Number.isFinite(idx)) setSelected(idx);
        setTargetFromPicker(col, { advanceStep: true });
        showToast(`Target set to ${col}`, "good");
    });
  }

    // ----------------------------
    // Setup rendering
    // ----------------------------
    function serializeSet(set) {
      return Array.from(set).sort((a, b) => a.localeCompare(b)).join(",");
    }

    function syncHiddenTypingLists() {
      APP.setup.excludeCols = serializeSet(APP.setup.excluded);
      APP.setup.forceDate = serializeSet(APP.setup.forcedTypes.date);
      APP.setup.forceCat = serializeSet(APP.setup.forcedTypes.categorical);
      APP.setup.forceCont = serializeSet(APP.setup.forcedTypes.continuous);
    }

    function forcedTypeForColumn(col) {
      if (APP.setup.forcedTypes.date.has(col)) return "date";
      if (APP.setup.forcedTypes.categorical.has(col)) return "categorical";
      if (APP.setup.forcedTypes.continuous.has(col)) return "continuous";
      return null;
    }

    function recomputeColumnMeta() {
      APP.setup.maxCard = Math.max(1, Math.floor(parseNum($("maxCard")?.value) || 50));

      const meta = {};
      for (const c of APP.raw.columns) {
        const auto = inferColumnType(c, APP.raw.rows, { maxCard: APP.setup.maxCard, forceType: null });
        let forced = forcedTypeForColumn(c);
        if (forced && forced === auto.inferredType) {
          if (forced === "date") APP.setup.forcedTypes.date.delete(c);
          else if (forced === "categorical") APP.setup.forcedTypes.categorical.delete(c);
          else if (forced === "continuous") APP.setup.forcedTypes.continuous.delete(c);
          forced = null;
        }

        const cur = inferColumnType(c, APP.raw.rows, { maxCard: APP.setup.maxCard, forceType: forced });
        meta[c] = { ...cur, autoType: auto.inferredType };
        meta[c].include = !APP.setup.excluded.has(c);
      }
      APP.raw.colMeta = meta;

      const targetCol = APP.raw.targetCol;
      if (targetCol && APP.raw.colMeta[targetCol]) APP.raw.colMeta[targetCol].include = true;

      syncHiddenTypingLists();
    }

    function computeTypeCounts() {
      const meta = APP.raw.colMeta;
      const counts = { date: 0, categorical: 0, continuous: 0, excluded: 0 };
      for (const c of APP.raw.columns) {
        const m = meta[c];
        if (!m) continue;
        if (!m.include) { counts.excluded++; continue; }
        if (m.inferredType === "date") counts.date++;
        else if (m.inferredType === "continuous") counts.continuous++;
        else counts.categorical++;
      }
      return { counts, maxCard: APP.setup.maxCard };
    }

    function renderColumnTable() {
      const meta = APP.raw.colMeta;
      const target = APP.raw.targetCol;

      const groups = [
        { key: "continuous", title: "Continuous" },
        { key: "categorical", title: "Categorical" },
        { key: "date", title: "Date" },
        { key: "excluded", title: "Excluded" },
      ];

      const sortKey = APP.ui.colSort?.key || "name";
      const sortDir = APP.ui.colSort?.dir || "asc";
      const dirMul = (sortDir === "asc") ? 1 : -1;
      const labelOfType = (t) => (t === "continuous") ? "2_cont" : (t === "categorical") ? "1_cat" : (t === "date") ? "3_date" : "9_other";

      const sortVal = (col) => {
        const m = meta[col];
        if (!m) return "";
        switch (sortKey) {
          case "include": return m.include ? 1 : 0;
          case "name": return col.toLowerCase();
          case "type": return labelOfType(m.inferredType);
          case "missing": return m.missingFrac ?? 0;
          case "unique": return m.uniqueSample ?? 0;
          case "flags": return (m.flags?.idLike ? 1 : 0);
          case "examples": return (m.examples?.[0] ?? "").toLowerCase();
          default: return col.toLowerCase();
        }
      };

      document.querySelectorAll("#reviewColumnsTable th.sortable[data-sort]").forEach(th => {
        const k = th.getAttribute("data-sort");
        const ind = th.querySelector(".sort-indicator");
        if (!ind) return;
        ind.textContent = (k === sortKey) ? (sortDir === "asc" ? "‚ñ≤" : "‚ñº") : "";
      });

      const rows = [];

      for (const g of groups) {
        const colsInGroup = APP.raw.columns.filter(col => {
          const m = meta[col];
          if (!m) return false;

          const groupKey = m.include ? m.inferredType : "excluded";
          if (groupKey !== g.key) return false;
          return true;
        });

        if (!colsInGroup.length) continue;

        colsInGroup.sort((a, b) => {
          const va = sortVal(a);
          const vb = sortVal(b);
          if (typeof va === "number" && typeof vb === "number") {
            if (va === vb) return a.toLowerCase().localeCompare(b.toLowerCase());
            return (va < vb ? -1 : 1) * dirMul;
          }
          const sa = String(va), sb = String(vb);
          if (sa === sb) return a.toLowerCase().localeCompare(b.toLowerCase());
          return (sa < sb ? -1 : 1) * dirMul;
        });

        rows.push(`<tr class="groupRow"><td colspan="7">${escapeHtml(g.title)} <span class="muted2">(${colsInGroup.length})</span></td></tr>`);

        for (const col of colsInGroup) {
          const m = meta[col];
          const missPct = (m.missingFrac * 100);
          const forced = forcedTypeForColumn(col);

          const lockedReason = lockedExcludedReason(col);
          const locked = Boolean(lockedReason);
          const includeDisabled = ((target && col === target) || locked) ? "disabled" : "";
          const includeChecked = ((target && col === target) || (!locked && m.include)) ? "checked" : "";
          const includeBox = `<input type="checkbox" data-include="${escapeHtml(col)}" ${includeChecked} ${includeDisabled} />`;

          const typeSelect = `
            <select data-coltype="${escapeHtml(col)}" style="width:170px;">
              <option value="categorical" ${m.inferredType==="categorical"?"selected":""}>categorical</option>
              <option value="continuous" ${m.inferredType==="continuous"?"selected":""}>continuous</option>
              <option value="date" ${m.inferredType==="date"?"selected":""}>date</option>
            </select>
            ${forced ? `<div class="muted2">auto=${escapeHtml(m.autoType || "‚Äî")}</div>` : ""}
          `;

          const flags = [];
          if (m.flags?.idLike) flags.push(`<span class="pill warn" title="Often acts like an ID">ID-like</span>`);
          if (forced) flags.push(`<span class="pill" title="Manually overridden">Forced</span>`);
          if (locked) flags.push(`<span class="pill warn" title="${escapeHtml(lockedReason)}">Locked</span>`);
          const flagsHtml = flags.length ? flags.join(" ") : `<span class="muted2">‚Äî</span>`;

          const examplesFull = (m.examples || [])
            .slice(0, 3)
            .map(x => truncate(x, 80))
            .join(", ");
          const examples = truncate(examplesFull, 200);

          rows.push(`
            <tr>
              <td>${includeBox}</td>
              <td class="mono">
                <span class="pickTarget ${target && col === target ? "active" : ""}" data-picktarget="${escapeHtml(col)}">${escapeHtml(col)}</span>
                ${target && col === target ? `<span class="pill good" style="margin-left:8px;">target</span>` : ""}
              </td>
              <td>${typeSelect}</td>
              <td>${escapeHtml(missPct.toFixed(1) + "%")}</td>
              <td>${escapeHtml(String(m.uniqueSample))}</td>
              <td>${flagsHtml}</td>
              <td title="${escapeHtml(examples)}">${escapeHtml(examples)}</td>
            </tr>
          `);
        }
      }

      $("colConfigBody").innerHTML = rows.join("");

      $("colConfigBody").querySelectorAll("input[type=checkbox][data-include]").forEach(cb => {
        cb.addEventListener("change", () => {
          const col = cb.getAttribute("data-include");
          const targetCol = APP.raw.targetCol;
          if (targetCol && col === targetCol) return;
          if (cb.checked) APP.setup.excluded.delete(col);
          else APP.setup.excluded.add(col);
          syncHiddenTypingLists();
          recomputeColumnMeta();
          refreshSplitDateCol();
          syncSetupUI();
          renderColumnTable();
          syncButtons();
        });
      });

      $("colConfigBody").querySelectorAll("select[data-coltype]").forEach(sel => {
        sel.addEventListener("change", () => {
          const col = sel.getAttribute("data-coltype");
          const picked = sel.value;
          APP.setup.forcedTypes.date.delete(col);
          APP.setup.forcedTypes.categorical.delete(col);
          APP.setup.forcedTypes.continuous.delete(col);

          const autoType = meta[col]?.autoType;
          if (picked !== autoType) {
            if (picked === "date") APP.setup.forcedTypes.date.add(col);
            else if (picked === "categorical") APP.setup.forcedTypes.categorical.add(col);
            else if (picked === "continuous") APP.setup.forcedTypes.continuous.add(col);
          }

          syncHiddenTypingLists();
          recomputeColumnMeta();
          refreshSplitDateCol();
          syncSetupUI();
          renderColumnTable();
          syncButtons();
        });
      });

      $("colConfigBody").querySelectorAll("[data-picktarget]").forEach(el => {
        el.addEventListener("click", () => {
          const col = el.getAttribute("data-picktarget");
          if (!col) return;
          APP.setup.excluded.delete(col);
          $("targetSelect").value = col;
          $("targetSelect").dispatchEvent(new Event("change"));
        });
      });
    }

    function listDateColumns() {
      const meta = APP.raw.colMeta;
      return APP.raw.columns.filter(c => meta[c]?.include && meta[c]?.inferredType === "date");
    }

    function decideTaskFromTarget(rows, targetCol, taskMode, meta) {
      if (taskMode === "regression") return "regression";
      if (taskMode === "classification") return "classification";

      const t = meta[targetCol]?.inferredType;
      if (t === "continuous") return "regression";
      if (t === "categorical") return "classification";
      if (t === "date") return "regression";

      const maxN = Math.min(rows.length, 1500);
      let nonEmpty = 0, numeric = 0, uniq = new Set();
      for (let i = 0; i < maxN; i++) {
        const s = normStr(rows[i][targetCol]);
        if (!s) continue;
        nonEmpty++;
        uniq.add(s);
        const x = parseNum(s);
        if (Number.isFinite(x)) numeric++;
      }
      const fracNum = nonEmpty ? (numeric / nonEmpty) : 0;
      if (fracNum >= 0.90 && uniq.size > 20) return "regression";
      return "classification";
    }

    function defaultTaskModeForTarget(rows, targetCol, meta) {
      const t = meta[targetCol]?.inferredType;
      if (t === "continuous") return "regression";
      if (t === "categorical") return "classification";
      if (t === "date") return "regression";
      return decideTaskFromTarget(rows, targetCol, null, meta);
    }

    function syncSetupUI() {
      $("rowsPill").textContent = `Rows: ${APP.raw.rows.length}`;
      $("colsPill").textContent = `Columns: ${APP.raw.columns.length}`;

      const { counts, maxCard } = computeTypeCounts();
      $("reviewPill").textContent = `Typing: cont=${counts.continuous} ¬∑ cat=${counts.categorical} ¬∑ date=${counts.date} ¬∑ max_card=${maxCard}`;

      const hasTarget = !!APP.raw.targetCol;
      $("continueToTrainBtn").disabled = !hasTarget;

      const decidedTask = hasTarget ? decideTaskFromTarget(APP.raw.rows, APP.raw.targetCol, APP.setup.taskMode, APP.raw.colMeta) : null;

      const taskPill = $("taskModeDetectedPill");
      if (taskPill) {
        const mode = $("taskMode")?.value || APP.setup.taskMode || "auto";
        if (mode === "auto" && decidedTask) {
          taskPill.textContent = `Detected: ${decidedTask === "regression" ? "Regression" : "Classification"}`;
          taskPill.classList.remove("hidden");
        } else {
          taskPill.textContent = "‚Äî";
          taskPill.classList.add("hidden");
        }
      }

      const dateCols = listDateColumns();
      const splitMode = effectiveSplitMode();
      const splitMethod = $("splitMethod").value || "cutoff";
      const cutoff = $("cutoffDate").value || "";
      APP.setup.splitMethod = splitMethod;
      APP.setup.cutoffDate = cutoff;
      const hasDates = dateCols.length > 0;
      const splitSel = $("splitStrategy");
      if (splitSel) {
        const cur = splitSel.value || "random";
        const options = [`<option value="random">Random</option>`]
          .concat(hasDates ? [`<option value="time">Time-based</option>`] : []);
        splitSel.innerHTML = options.join("");
        splitSel.value = (cur === "time" && hasDates) ? "time" : "random";
        splitSel.disabled = !hasDates;
      }
      APP.setup.splitStrategy = $("splitStrategy")?.value || "random";

      $("splitDateCol").innerHTML = dateCols.length
        ? dateCols.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("")
        : `<option value="">(no date columns detected)</option>`;

      if (!APP.setup.splitDateCol && dateCols.length) APP.setup.splitDateCol = dateCols[0];
      if (APP.setup.splitDateCol && dateCols.includes(APP.setup.splitDateCol)) $("splitDateCol").value = APP.setup.splitDateCol;

      $("timeSplitSettings").classList.toggle("hidden", !(hasDates && splitMode === "time"));
      $("cutoffField").classList.toggle("hidden", !(splitMode === "time" && splitMethod === "cutoff"));
      $("cutoffDate").disabled = !(splitMode === "time" && splitMethod === "cutoff");
      $("testFrac").disabled = !(splitMode === "random" || (splitMode === "time" && splitMethod === "fraction") || (splitMode === "time" && splitMethod === "cutoff" && !cutoff));

      const c = $("setupCallout");
      if (!hasTarget) {
        c.className = "callout";
        c.innerHTML = `<div style="font-weight:650;margin-bottom:6px;">Click a column name to select the target</div>
                       <div class="muted2">Or use the dropdown on the left.</div>`;
        show(c);
      } else {
        const splitText = (splitMode === "time")
          ? (splitMethod === "cutoff" && cutoff
            ? `Time-based split: train &lt; <span class="mono">${escapeHtml(cutoff)}</span>, valid ‚â• cutoff (column <span class="mono">${escapeHtml(APP.setup.splitDateCol || dateCols[0] || "")}</span>).`
            : `Time-based split using <span class="mono">${escapeHtml(APP.setup.splitDateCol || dateCols[0] || "")}</span> (fraction fallback).`)
          : `Random split.`;

        const idLike = APP.raw.columns.filter(cc => APP.raw.colMeta[cc]?.include && APP.raw.colMeta[cc]?.flags?.idLike);
        const idHint = idLike.length
          ? `<div class="muted2" style="margin-top:6px;">We flagged ${idLike.length} ID-like column(s). Consider excluding them in ‚ÄúReview columns‚Äù if you care about robustness.</div>`
          : ``;

        const extrapolationWarn = (splitMode === "time")
          ? `<div class="muted2" style="margin-top:8px;"><span class="pill warn">Extrapolation warning</span>
               Forests can‚Äôt extrapolate beyond the target range. If your target trends over time, expect systematic underprediction on future rows.</div>`
          : "";

        c.className = (splitMode === "time") ? "callout warn" : "callout";
        c.innerHTML = `<div style="font-weight:650;margin-bottom:6px;">Ready</div>
                       <div class="muted2">${splitText} You can train immediately.</div>${extrapolationWarn}${idHint}`;
        show(c);
      }

      syncAdvancedTargetUI();
    }

    // ----------------------------
    // Advanced target options (multi-class classification)
    // ----------------------------
    function isDerivedTargetActive() {
      const dt = APP.setup.multiClass?.derivedTarget || null;
      if (!dt || !dt.enabled) return false;
      if (!dt.derivedCol) return false;
      return APP.raw.targetCol === dt.derivedCol;
    }

    function lockedExcludedReason(col) {
      const dt = APP.setup.multiClass?.derivedTarget || null;
      if (!dt || !dt.enabled) return null;
      if (!dt.sourceCol || !dt.derivedCol) return null;
      if (APP.raw.targetCol !== dt.derivedCol) return null;
      if (col !== dt.sourceCol) return null;
      return "Excluded to prevent leakage from the original target.";
    }

    function sampleIndicesNoAlloc(n, k, seed) {
      const nn = Math.max(0, Math.floor(n || 0));
      const kk = Math.max(0, Math.min(nn, Math.floor(k || 0)));
      if (kk >= nn) return Array.from({ length: nn }, (_, i) => i);
      const rng = mulberry32(seed >>> 0);
      const out = new Set();
      for (let i = nn - kk; i < nn; i++) {
        const t = Math.floor(rng() * (i + 1));
        if (out.has(t)) out.add(i);
        else out.add(t);
      }
      return Array.from(out);
    }

    function computeCategoricalCounts(rows, col, { maxSample = 8000, seed = 1337 } = {}) {
      if (!col) return { counts: new Map(), nSampled: 0, nMissing: 0 };
      const idx = sampleIndicesNoAlloc(rows.length, maxSample, seed);
      const counts = new Map();
      let missing = 0;
      for (const i of idx) {
        const s = normStr(rows[i]?.[col]);
        if (!s) { missing++; continue; }
        counts.set(s, (counts.get(s) || 0) + 1);
      }
      return { counts, nSampled: idx.length, nMissing: missing };
    }

    function sortedCountEntries(counts) {
      return Array.from(counts.entries())
        .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])));
    }

	    function defaultDerivedTargetColName(sourceCol) {
	      const base = normStr(sourceCol) || "target";
	      return `${base}_is`;
	    }

	    function isValidExprValueIdent(word) {
	      if (!word) return false;
	      if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(word)) return false;
	      const kw = word.toLowerCase();
	      return !(kw === "and" || kw === "or" || kw === "not" || kw === "in" || kw === "len" || kw === "true" || kw === "false" || kw === "none");
	    }

	    function exprValueIdentForColumnName(col) {
	      const raw = normStr(col);
	      if (!raw) return "o";
	      if (isValidExprValueIdent(raw)) return raw;
	      let out = raw.replace(/[^A-Za-z0-9_]/g, "_").replace(/_+/g, "_");
	      if (!out) out = "o";
	      if (!/^[A-Za-z_]/.test(out)) out = `_${out}`;
	      if (!isValidExprValueIdent(out)) out = `${out}_`;
	      return out;
	    }

	    function compilePythonicBoolExpr(exprRaw, { valueIdent = "o" } = {}) {
	      const expr = normStr(exprRaw);
	      if (!expr) throw new Error("Expression is required.");

	      const s = expr;
      const tokens = [];
      let i = 0;

      const isWs = (c) => /\s/.test(c);
      const isDigit = (c) => /[0-9]/.test(c);
      const isIdentStart = (c) => /[A-Za-z_]/.test(c);
      const isIdentChar = (c) => /[A-Za-z0-9_]/.test(c);

      const push = (type, value = null) => tokens.push({ type, value });

      while (i < s.length) {
        const c = s[i];
        if (isWs(c)) { i++; continue; }

        if (c === "(" || c === ")" || c === "[" || c === "]" || c === ",") {
          push(c);
          i++;
          continue;
        }

        if (c === "'" || c === "\"") {
          const quote = c;
          i++;
          let out = "";
          let closed = false;
          while (i < s.length) {
            const ch = s[i];
            if (ch === quote) { i++; closed = true; break; }
            if (ch === "\\") {
              const nxt = s[i + 1];
              if (nxt === undefined) throw new Error("Unterminated string escape.");
              if (nxt === "n") out += "\n";
              else if (nxt === "t") out += "\t";
              else out += nxt;
              i += 2;
              continue;
            }
            out += ch;
            i++;
          }
          if (!closed) throw new Error("Unterminated string literal.");
          push("string", out);
          continue;
        }

        if ((c === "-" && (isDigit(s[i + 1]) || (s[i + 1] === "." && isDigit(s[i + 2])))) || isDigit(c) || (c === "." && isDigit(s[i + 1]))) {
          const start = i;
          i++; // consume first char
          while (i < s.length) {
            const ch = s[i];
            if (isDigit(ch) || ch === "." || ch === "e" || ch === "E" || ch === "+" || ch === "-") i++;
            else break;
          }
          const raw = s.slice(start, i);
          const num = Number(raw);
          if (!Number.isFinite(num)) throw new Error(`Invalid number literal: ${raw}`);
          push("number", num);
          continue;
        }

	        if (isIdentStart(c)) {
	          const start = i;
	          i++;
	          while (i < s.length && isIdentChar(s[i])) i++;
	          const word = s.slice(start, i);
	          const kw = word.toLowerCase();
	          if (kw === "and" || kw === "or" || kw === "not" || kw === "in" || kw === "len") push("kw", kw);
	          else if (kw === "true") push("boolean", true);
	          else if (kw === "false") push("boolean", false);
	          else if (kw === "none") push("none", null);
	          else if (word === "o" || word === valueIdent) push("ident", "o");
	          else throw new Error(`Unknown identifier: ${word}`);
	          continue;
	        }

        const two = s.slice(i, i + 2);
        if (two === "==" || two === "!=" || two === "<=" || two === ">=") { push("op", two); i += 2; continue; }
        if (c === "<" || c === ">") { push("op", c); i++; continue; }

        throw new Error(`Unexpected character: ${c}`);
      }
      push("eof");

      let tok = 0;
      const cur = () => tokens[tok];
      const eat = (type, value = null) => {
        const t = cur();
        if (!t || t.type !== type) return false;
        if (value !== null && t.value !== value) return false;
        tok++;
        return true;
      };
      const expect = (type, value = null) => {
        const t = cur();
        if (!eat(type, value)) {
          const v = (t && t.type === "kw") ? t.value : (t && t.value !== null ? t.value : t?.type);
          throw new Error(`Expected ${value !== null ? `${type}(${value})` : type}, got ${v || "end"}.`);
        }
      };

      const parseExpr = () => parseOr();

      const parseOr = () => {
        let node = parseAnd();
        while (eat("kw", "or")) node = { t: "or", a: node, b: parseAnd() };
        return node;
      };

      const parseAnd = () => {
        let node = parseNot();
        while (eat("kw", "and")) node = { t: "and", a: node, b: parseNot() };
        return node;
      };

      const parseNot = () => {
        if (eat("kw", "not")) return { t: "not", a: parseNot() };
        return parseCmp();
      };

      const parseCollection = () => {
        const open = cur();
        if (!eat("(") && !eat("[")) throw new Error("Expected a list/tuple after 'in'.");
        const close = (open.type === "(") ? ")" : "]";
        const items = [];
        if (eat(close)) return items;
        while (true) {
          const t = cur();
          if (t.type === "number") { items.push({ t: "number", v: t.value }); tok++; }
          else if (t.type === "string") { items.push({ t: "string", v: t.value }); tok++; }
          else if (t.type === "boolean") { items.push({ t: "boolean", v: t.value }); tok++; }
          else if (t.type === "none") { items.push({ t: "none", v: null }); tok++; }
          else throw new Error("Only literals are allowed inside ( ... ) for 'in'.");

          if (eat(",")) {
            if (eat(close)) break;
            continue;
          }
          expect(close);
          break;
        }
        return items;
      };

      const parseCmp = () => {
        const left = parsePrimary();
        const t = cur();
        if (t.type === "op") {
          tok++;
          const right = parsePrimary();
          return { t: "cmp", op: t.value, a: left, b: right };
        }
        if (t.type === "kw" && t.value === "in") {
          tok++;
          const items = parseCollection();
          return { t: "in", not: false, a: left, items };
        }
        if (t.type === "kw" && t.value === "not") {
          if (tokens[tok + 1]?.type === "kw" && tokens[tok + 1]?.value === "in") {
            tok += 2;
            const items = parseCollection();
            return { t: "in", not: true, a: left, items };
          }
        }
        return left;
      };

      const parsePrimary = () => {
        const t = cur();
        if (t.type === "number") { tok++; return { t: "number", v: t.value }; }
        if (t.type === "string") { tok++; return { t: "string", v: t.value }; }
        if (t.type === "boolean") { tok++; return { t: "boolean", v: t.value }; }
        if (t.type === "none") { tok++; return { t: "none", v: null }; }
        if (t.type === "ident" && t.value === "o") { tok++; return { t: "o" }; }
        if (t.type === "kw" && t.value === "len") {
          tok++;
          expect("(");
          const arg = parseExpr();
          expect(")");
          return { t: "len", a: arg };
        }
	        if (eat("(")) {
	          const inner = parseExpr();
	          expect(")");
	          return inner;
	        }
	        throw new Error("Expected a value (number/string/identifier/len(...)/(...)).");
	      };

      const ast = parseExpr();
      expect("eof");

      const truthy = (v) => {
        if (v === null || v === undefined) return false;
        if (typeof v === "boolean") return v;
        if (typeof v === "number") return Number.isFinite(v) && v !== 0;
        if (typeof v === "string") return v.length > 0;
        if (Array.isArray(v)) return v.length > 0;
        return Boolean(v);
      };

      const toNum = (v) => {
        if (typeof v === "number") return v;
        if (typeof v === "boolean") return v ? 1 : 0;
        const s = normStr(v);
        if (!s) return NaN;
        const n = Number(s);
        return Number.isFinite(n) ? n : NaN;
      };

      const eq = (a, b) => {
        if (a === null || b === null) return a === b;
        if (typeof a === typeof b) return a === b;
        if (typeof a === "number" || typeof b === "number") {
          const na = toNum(a), nb = toNum(b);
          if (Number.isFinite(na) && Number.isFinite(nb)) return na === nb;
        }
        return String(a) === String(b);
      };

      const inList = (val, items) => {
        const hasNum = items.some(x => typeof x === "number");
        const hasStr = items.some(x => typeof x === "string");
        if (hasNum && !hasStr) {
          const n = toNum(val);
          if (!Number.isFinite(n)) return false;
          return items.includes(n);
        }
        if (hasStr && !hasNum) {
          const s0 = String(val);
          return items.includes(s0);
        }
        const s0 = String(val);
        const n0 = toNum(val);
        for (const it of items) {
          if (typeof it === "number") {
            if (Number.isFinite(n0) && it === n0) return true;
          } else if (typeof it === "string") {
            if (it === s0) return true;
          } else {
            if (it === val) return true;
          }
        }
        return false;
      };

      const evalNode = (node, oVal) => {
        switch (node.t) {
          case "number": return node.v;
          case "string": return node.v;
          case "boolean": return node.v;
          case "none": return null;
          case "o": return oVal;
          case "len": return String(evalNode(node.a, oVal) ?? "").length;
          case "not": return !truthy(evalNode(node.a, oVal));
          case "and": return truthy(evalNode(node.a, oVal)) && truthy(evalNode(node.b, oVal));
          case "or": return truthy(evalNode(node.a, oVal)) || truthy(evalNode(node.b, oVal));
          case "cmp": {
            const a = evalNode(node.a, oVal);
            const b = evalNode(node.b, oVal);
            switch (node.op) {
              case "==": return eq(a, b);
              case "!=": return !eq(a, b);
              case "<":
              case "<=":
              case ">":
              case ">=": {
                const na = toNum(a), nb = toNum(b);
                if (Number.isFinite(na) && Number.isFinite(nb)) {
                  if (node.op === "<") return na < nb;
                  if (node.op === "<=") return na <= nb;
                  if (node.op === ">") return na > nb;
                  return na >= nb;
                }
                const sa = String(a), sb = String(b);
                if (node.op === "<") return sa < sb;
                if (node.op === "<=") return sa <= sb;
                if (node.op === ">") return sa > sb;
                return sa >= sb;
              }
              default: throw new Error(`Unsupported operator: ${node.op}`);
            }
          }
          case "in": {
            const a = evalNode(node.a, oVal);
            const items = node.items.map(x => (x.t === "none") ? null : x.v);
            const hit = inList(a, items);
            return node.not ? !hit : hit;
          }
          default:
            throw new Error("Unsupported expression.");
        }
      };

      return (o) => Boolean(truthy(evalNode(ast, normStr(o))));
    }

	    function applyDerivedTargetFromExpr() {
	      const dt = APP.setup.multiClass?.derivedTarget || null;
	      if (!dt) return;

      const currentTarget = APP.raw.targetCol;
      const sourceCol = (dt.enabled && dt.derivedCol && dt.sourceCol && currentTarget === dt.derivedCol)
        ? dt.sourceCol
        : currentTarget;
      if (!sourceCol) throw new Error("Pick a target column first.");

      const expr = normStr($("derivedTargetExpr")?.value);
      const derivedCol = normStr($("derivedTargetColName")?.value) || defaultDerivedTargetColName(sourceCol);

      if (!expr) throw new Error("Provide an expression.");
      if (!derivedCol) throw new Error("Provide a new column name.");

      const existing = APP.raw.columns.includes(derivedCol);
      const allowedOverwrite = (dt.enabled && dt.derivedCol === derivedCol);
      if (existing && !allowedOverwrite) throw new Error(`Column already exists: ${derivedCol}`);

      if (dt.enabled && dt.derivedCol && dt.derivedCol !== derivedCol) {
        const prev = dt.derivedCol;
        for (const r of APP.raw.rows) delete r[prev];
        APP.raw.columns = APP.raw.columns.filter(c => c !== prev);
        APP.setup.excluded.delete(prev);
      }

	      const valueIdent = exprValueIdentForColumnName(sourceCol);
	      const pred = compilePythonicBoolExpr(expr, { valueIdent });

      let tCount = 0, fCount = 0;
      for (const r of APP.raw.rows) {
        const o = r ? r[sourceCol] : "";
        const v = pred(o);
        r[derivedCol] = v ? "true" : "false";
        if (v) tCount++;
        else fCount++;
      }

      if (!existing) APP.raw.columns.push(derivedCol);

      dt.enabled = true;
      dt.sourceCol = sourceCol;
      dt.derivedCol = derivedCol;
      dt.expr = expr;
      dt.lastError = "";
      dt.lastStatus = `Created ${derivedCol}: true=${tCount}, false=${fCount}.`;

      APP.setup.excluded.add(sourceCol);
      APP.setup.excluded.delete(derivedCol);

      renderTargetSelect();
      $("targetSelect").value = derivedCol;
      $("targetSelect").dispatchEvent(new Event("change"));

      const statusEl = $("derivedTargetStatus");
      if (statusEl) {
        statusEl.innerHTML = `<span class="pill good">Ready</span> <span class="mono">${escapeHtml(dt.lastStatus)}</span>`;
      }
    }

    function undoDerivedTarget() {
      const dt = APP.setup.multiClass?.derivedTarget || null;
      if (!dt || !dt.enabled) return;

      const sourceCol = dt.sourceCol;
      const derivedCol = dt.derivedCol;

      if (derivedCol) {
        for (const r of APP.raw.rows) delete r[derivedCol];
        APP.raw.columns = APP.raw.columns.filter(c => c !== derivedCol);
        APP.setup.excluded.delete(derivedCol);
      }

      if (sourceCol) APP.setup.excluded.delete(sourceCol);

      dt.enabled = false;
      dt.sourceCol = null;
      dt.derivedCol = "";
      dt.expr = "";
      dt.lastError = "";
      dt.lastStatus = "";

      if (sourceCol) APP.raw.targetCol = sourceCol;

      renderTargetSelect();
      if (sourceCol) $("targetSelect").value = sourceCol;
      $("targetSelect").dispatchEvent(new Event("change"));

      const statusEl = $("derivedTargetStatus");
      if (statusEl) statusEl.textContent = "‚Äî";
    }

	    function syncAdvancedTargetUI() {
	      const details = $("advancedTargetDetails");
	      if (!details) return;

      const topNState = APP.setup.multiClass?.topN || { enabled: false, keep: 5, rareLabel: "RARE" };
      const dt = APP.setup.multiClass?.derivedTarget || { enabled: false, sourceCol: null, derivedCol: "", expr: "", lastStatus: "", lastError: "" };

      const targetCol = APP.raw.targetCol;
      const hasTarget = Boolean(targetCol);
      const task = hasTarget ? decideTaskFromTarget(APP.raw.rows, targetCol, APP.setup.taskMode, APP.raw.colMeta) : null;

      const sourceCol = (dt.enabled && dt.sourceCol) ? dt.sourceCol : targetCol;
      const canShow = Boolean(hasTarget && task === "classification" && sourceCol);

      if (!canShow) {
        details.classList.add("hidden");
        return;
      }

      const info = computeCategoricalCounts(APP.raw.rows, sourceCol, { maxSample: 8000, seed: 1337 });
      const numClasses = info.counts.size;
      const isMultiClass = numClasses > 2;
      const showDetails = isMultiClass || topNState.enabled || dt.enabled;
      details.classList.toggle("hidden", !showDetails);
      if (!showDetails) return;

      const callout = $("multiClassSummaryCallout");
      if (callout) {
        const top = sortedCountEntries(info.counts).slice(0, 6);
        const topText = top.length
          ? top.map(([k, v]) => `${escapeHtml(truncate(k, 30))} (${v})`).join(", ")
          : "‚Äî";
        const missTxt = info.nMissing ? ` ¬∑ missing=${info.nMissing}` : "";
        callout.innerHTML =
          `<div style="font-weight:650;margin-bottom:6px;">Target summary (sample)</div>` +
          `<div class="muted2">Column <span class="mono">${escapeHtml(sourceCol)}</span> ¬∑ classes=${numClasses} ¬∑ sampled=${info.nSampled}${missTxt}</div>` +
          `<div class="muted2" style="margin-top:6px;">Top: ${topText}</div>`;
      }

      const topNEnableEl = $("topNEnable");
      const topNKeepEl = $("topNKeep");
      const derivedActive = isDerivedTargetActive();
      if (topNEnableEl) {
        topNEnableEl.checked = Boolean(topNState.enabled);
        topNEnableEl.disabled = derivedActive;
      }
      if (topNKeepEl) {
        topNKeepEl.value = String(Math.max(1, Math.floor(topNState.keep || 5)));
        topNKeepEl.disabled = derivedActive || !Boolean(topNState.enabled);
      }

      const topNSummaryEl = $("topNSummary");
      if (topNSummaryEl) {
        if (derivedActive) topNSummaryEl.textContent = "Disabled (derived target is active).";
        else if (!topNState.enabled) topNSummaryEl.textContent = "Disabled.";
        else {
          const keepN = Math.max(1, Math.floor(topNState.keep || 1));
          const entries = sortedCountEntries(info.counts);
          const kept = entries.slice(0, Math.min(keepN, entries.length));
          const hasRare = entries.length > kept.length;
          const outK = Math.min(keepN, entries.length) + (hasRare ? 1 : 0);
          const keptText = kept.length ? kept.map(([k, v]) => `${truncate(k, 30)} (${v})`).join(", ") : "‚Äî";
          topNSummaryEl.textContent = `Keeps: ${keptText}${hasRare ? ` ¬∑ Others ‚Üí ${topNState.rareLabel} ¬∑ New classes‚âà${outK}` : " ¬∑ No rare classes in sample."}`;
        }
      }

	      const applyBtn = $("applyDerivedTargetBtn");
	      const undoBtn = $("undoDerivedTargetBtn");
	      const nameEl = $("derivedTargetColName");
	      const exprEl = $("derivedTargetExpr");
	      const valueIdent = exprValueIdentForColumnName(sourceCol);

	      const valueIdentEl = $("derivedTargetValueIdent");
	      if (valueIdentEl) valueIdentEl.textContent = valueIdent;
	      const ex1El = $("derivedTargetExprExample1");
	      if (ex1El) ex1El.textContent = `${valueIdent} in (6,7,8)`;
	      const ex2El = $("derivedTargetExprExample2");
	      if (ex2El) ex2El.textContent = `len(${valueIdent}) > 5`;

	      if (nameEl && !normStr(nameEl.value)) {
	        nameEl.placeholder = defaultDerivedTargetColName(sourceCol);
	      }
	      if (exprEl) {
	        exprEl.placeholder = `e.g. ${valueIdent} in (6,7,8) or len(${valueIdent}) > 5`;
	      }
	      if (exprEl && dt.enabled && normStr(dt.expr) && !exprEl.dataset.userSet) {
	        exprEl.value = dt.expr;
	      }
      if (nameEl && dt.enabled && dt.derivedCol && !nameEl.dataset.userSet) {
        nameEl.value = dt.derivedCol;
      }

      if (applyBtn) {
        const expr = normStr(exprEl?.value);
        applyBtn.disabled = !expr;
      }
      if (undoBtn) undoBtn.disabled = !dt.enabled;

      const statusEl = $("derivedTargetStatus");
      if (statusEl) {
        if (dt.lastError) {
          statusEl.innerHTML = `<span class="pill bad">Error</span> <span class="mono">${escapeHtml(dt.lastError)}</span>`;
        } else if (dt.enabled && dt.derivedCol && dt.sourceCol) {
          const active = isDerivedTargetActive();
          const activeTxt = active ? " (active)" : "";
          statusEl.innerHTML =
            `<span class="pill good">Ready</span> ` +
            `<span class="muted2">Derived <span class="mono">${escapeHtml(dt.derivedCol)}</span> from <span class="mono">${escapeHtml(dt.sourceCol)}</span>${activeTxt}.</span>`;
        } else {
          statusEl.textContent = "‚Äî";
        }
      }
    }

    function renderTargetSelect() {
      const cols = APP.raw.columns;
      const options = cols.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("");
      $("targetSelect").innerHTML = `<option value="" disabled ${APP.raw.targetCol ? "" : "selected"}>(select a column)</option>` + options;

      if (APP.raw.targetCol) $("targetSelect").value = APP.raw.targetCol;
    }

    function renderTrainChips() {
      const el = $("trainChips");
      if (!el) return;

      const chips = [];
      const add = (label, value) => {
        if (value === null || value === undefined || value === "") return;
        chips.push(`<span class="pill">${escapeHtml(label)}: <span class="mono">${escapeHtml(String(value))}</span></span>`);
      };

      if (APP.raw.fileName) add("File", APP.raw.fileName);
      if (APP.raw.rows.length && APP.raw.columns.length) add("Data", `${APP.raw.rows.length} rows ¬∑ ${APP.raw.columns.length} cols`);

      if (APP.raw.targetCol) add("Target", APP.raw.targetCol);

      if (APP.raw.targetCol) {
        const task = decideTaskFromTarget(APP.raw.rows, APP.raw.targetCol, APP.setup.taskMode, APP.raw.colMeta);
        add("Task", task);
      }

      const topNState = APP.setup.multiClass?.topN || null;
      if (topNState?.enabled && !isDerivedTargetActive()) {
        add("TopN", `${Math.max(1, Math.floor(topNState.keep || 1))} + ${topNState.rareLabel || "RARE"}`);
      }

      const dt = APP.setup.multiClass?.derivedTarget || null;
      if (dt?.enabled && dt.sourceCol && dt.derivedCol && APP.raw.targetCol === dt.derivedCol) {
        add("Derived", `${dt.sourceCol} ‚Üí ${dt.derivedCol}`);
      }

      const splitMode = effectiveSplitMode();
      if (splitMode === "time") {
        const method = $("splitMethod")?.value || "cutoff";
        const cutoff = $("cutoffDate")?.value || "";
        const details = (method === "cutoff" && cutoff) ? `cutoff ${cutoff}` : `test ${Math.round(APP.setup.testFrac * 100)}%`;
        add("Split", `time (${APP.setup.splitDateCol || "‚Äî"}) ¬∑ ${details}`);
      }
      else add("Split", "random");
      if (splitMode === "random") add("Test", `${Math.round(APP.setup.testFrac * 100)}%`);

      add("Max rows", String(APP.setup.maxRows || 0) === "0" ? "all" : APP.setup.maxRows);

      const { counts, maxCard } = computeTypeCounts();
      add("Typing", `cont=${counts.continuous} ¬∑ cat=${counts.categorical} ¬∑ date=${counts.date}`);
      add("max_card", maxCard);

      const excludedCount = APP.setup.excluded?.size || 0;
      const forcedCount =
        (APP.setup.forcedTypes?.date?.size || 0) +
        (APP.setup.forcedTypes?.categorical?.size || 0) +
        (APP.setup.forcedTypes?.continuous?.size || 0);
      if (excludedCount) add("Excluded", excludedCount);
      if (forcedCount) add("Forced", forcedCount);

      el.innerHTML = chips.length ? chips.join(" ") : `<span class="muted2">Pick a target to preview training settings.</span>`;
    }

    function refreshSplitDateCol() {
      const dateCols = APP.raw.columns.filter(c => APP.raw.colMeta[c]?.include && APP.raw.colMeta[c]?.inferredType === "date");
      const current = APP.setup.splitDateCol;

      $("splitDateCol").innerHTML = dateCols.length
        ? dateCols.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("")
        : `<option value="">(no date columns detected)</option>`;

      if (dateCols.length) {
        if (current && dateCols.includes(current)) {
          $("splitDateCol").value = current;
        } else {
          APP.setup.splitDateCol = dateCols[0];
          $("splitDateCol").value = dateCols[0];
        }
      } else {
        APP.setup.splitDateCol = null;
      }

      syncSetupUI();
    }

    // ----------------------------
    // Build dataset + preprocessing (fit on TRAIN only)
    // ----------------------------
    function sampleRowIndices(nRows, maxRows, seed, mode = "random") {
      if (!maxRows || maxRows <= 0 || nRows <= maxRows) {
        return Array.from({ length: nRows }, (_, i) => i);
      }
      if (mode === "time") {
        const start = Math.max(0, nRows - maxRows);
        return Array.from({ length: maxRows }, (_, k) => start + k);
      }
      const rng = mulberry32(seed);
      const idx = Array.from({ length: nRows }, (_, i) => i);
      shuffleInPlace(idx, rng);
      return idx.slice(0, maxRows);
    }

    function parseMaxFeatures(v, nFeatures) {
      const s = normStr(v);
      if (!s) return 1.0;
      const kw = s.toLowerCase();
      if (kw === "sqrt") return Math.max(1, Math.floor(Math.sqrt(nFeatures)));
      if (kw === "log2") return Math.max(1, Math.floor(Math.log2(nFeatures)));
      const x = Number(s);
      if (!Number.isFinite(x)) return 1.0;
      if (x > 0 && x < 1) return x;
      const k = Math.floor(x);
      if (k >= 1) return Math.min(k, nFeatures);
      return 1.0;
    }

    function parseOptionalPositiveInt(v) {
      const s = normStr(v);
      if (!s) return null;
      const x = Math.floor(Number(s));
      if (!Number.isFinite(x) || x <= 0) return null;
      return x;
    }

    function estimateDerivedFeatureCount() {
      const targetCol = APP.raw.targetCol;
      const meta = APP.raw.colMeta || {};
      if (!targetCol) return 0;

      const featureCols = APP.raw.columns.filter(c => c !== targetCol && meta[c]?.include);
      const cont = featureCols.filter(c => meta[c]?.inferredType === "continuous").length;
      const cat = featureCols.filter(c => meta[c]?.inferredType === "categorical").length;
      const date = featureCols.filter(c => meta[c]?.inferredType === "date").length;

      const DATE_FEATURES_PER_COL = 14; // 13 parts + _na
      return (cont * 2) + (cat * 1) + (date * DATE_FEATURES_PER_COL);
    }

    function suggestMaxFeaturesValue(task) {
      return "1.0";
    }

    function suggestTreeOptions({ nRows, nFeatures }) {
      const nr = Math.max(1, Math.floor(nRows || 1));
      const nf = Math.max(1, Math.floor(nFeatures || 1));
      const featurePenalty = Math.max(0, Math.floor(Math.log2(nf)) - 8); // >256 derived features => shallower
      const maxDepthBase = Math.floor(Math.log2(nr)) + 6;
      const maxDepth = Math.min(24, Math.max(16, maxDepthBase - featurePenalty));
      const minNumSamples = Math.min(20, Math.max(5, Math.floor(nr / 2000)));
      return { maxDepth, minNumSamples };
    }

    function applyAutoTrainDefaults() {
      if (!APP.raw.targetCol) return;

      const maxRows = Math.floor(parseNum($("maxRows")?.value) || 0);
      const rawN = APP.raw.rows.length || 0;
      const nRows = (maxRows > 0) ? Math.min(rawN, maxRows) : rawN;
      const nFeatures = estimateDerivedFeatureCount();

      const task = decideTaskFromTarget(APP.raw.rows, APP.raw.targetCol, APP.setup.taskMode, APP.raw.colMeta);

      const mfEl = $("maxFeatures");
      const mdEl = $("maxDepth");
      const msEl = $("minNumSamples");
      if (!mfEl || !mdEl || !msEl) return;

      const suggestedMf = suggestMaxFeaturesValue(task);
      const suggestedTree = suggestTreeOptions({ nRows, nFeatures });

      if (!mfEl.dataset.userSet) mfEl.value = suggestedMf;
      if (!mdEl.dataset.userSet) mdEl.value = String(suggestedTree.maxDepth);
      if (!msEl.dataset.userSet) msEl.value = String(suggestedTree.minNumSamples);
    }

    function buildInverseMapping(mappingObj) {
      if (!mappingObj) return null;
      const inv = {};
      for (const [k, v] of Object.entries(mappingObj)) inv[v] = k;
      return inv;
    }

    function getRowTargetValue(row, targetCol, task, targetTransform, meta) {
      if (task === "regression") {
        const tType = meta[targetCol]?.inferredType;
        let yiRaw;
        if (tType === "date") {
          const d = parseDate(row[targetCol]);
          if (!d) return null;
          yiRaw = d.getTime();
        } else {
          const x = parseNum(row[targetCol]);
          if (!Number.isFinite(x)) return null;
          yiRaw = x;
        }

        if (targetTransform === "log1p") {
          if (yiRaw < 0) return null;
          return { yRaw: yiRaw, y: Math.log1p(yiRaw) };
        }
        return { yRaw: yiRaw, y: yiRaw };
      } else {
        const s = normStr(row[targetCol]) || "#na#";
        return { yRaw: s, y: s };
      }
    }

    function transformRowToFeatures(row, pipeline) {
      const contCols = pipeline.preprocess.continuous.cols;
      const catCols  = pipeline.preprocess.categorical.cols;
      const dateCols = pipeline.preprocess.date.cols;

      const feats = [];

      for (const c of contCols) {
        const x = parseNum(row[c]);
        const miss = !Number.isFinite(x);
        feats.push(miss ? pipeline.preprocess.continuous.median[c] : x);
        feats.push(miss ? 1 : 0);
      }

      for (const c of catCols) {
        const s = normStr(row[c]) || pipeline.preprocess.categorical.missingToken;
        const m = pipeline.preprocess.categorical.mapping[c];
        feats.push((m[s] === undefined) ? pipeline.preprocess.categorical.unknownId : m[s]);
      }

      for (const c of dateCols) {
        const d = parseDate(row[c]);
        const miss = !d;
        const dt = miss ? new Date(pipeline.preprocess.date.medianElapsed[c]) : d;
        const p = dateParts(dt);

        feats.push(p.year);
        feats.push(p.month);
        feats.push(p.week);
        feats.push(p.day);
        feats.push(p.dayofweek);
        feats.push(p.dayofyear);
        feats.push(p.is_month_end);
        feats.push(p.is_month_start);
        feats.push(p.is_quarter_end);
        feats.push(p.is_quarter_start);
        feats.push(p.is_year_end);
        feats.push(p.is_year_start);
        feats.push(p.elapsed);
        feats.push(miss ? 1 : 0);
      }

      return feats;
    }

    function buildDataset(seed, testFrac, splitMode, splitDateCol) {
      const rows = APP.raw.rows;
      const columns = APP.raw.columns;
      const targetCol = APP.raw.targetCol;
      const meta = APP.raw.colMeta;

      const maxRows = Math.floor(parseNum($("maxRows").value) || 0);

      const usedIdx = sampleRowIndices(rows.length, maxRows, seed, splitMode);
      const sampledRows = usedIdx.map(i => rows[i]);

      const includeCols = columns.filter(c => (c === targetCol) || (meta[c]?.include));
      const featureCols = includeCols.filter(c => c !== targetCol);

      const contCols = featureCols.filter(c => meta[c]?.inferredType === "continuous");
      const catCols  = featureCols.filter(c => meta[c]?.inferredType === "categorical");
      const dateCols = featureCols.filter(c => meta[c]?.inferredType === "date");

      const task = decideTaskFromTarget(sampledRows, targetCol, APP.setup.taskMode, meta);
      const targetTransform = APP.setup.targetTransform;

      // derived feature schema
      const DATE_PARTS = [
        "year","month","week","day","dayofweek","dayofyear",
        "is_month_end","is_month_start","is_quarter_end","is_quarter_start","is_year_end","is_year_start",
        "elapsed"
      ];

      const featureNames = [];
      const baseForDerived = [];

      for (const c of contCols) {
        featureNames.push(c); baseForDerived.push(c);
        featureNames.push(`${c}_na`); baseForDerived.push(c);
      }
      for (const c of catCols) {
        featureNames.push(c); baseForDerived.push(c);
      }
      for (const c of dateCols) {
        for (const p of DATE_PARTS) { featureNames.push(`${c}_${p}`); baseForDerived.push(c); }
        featureNames.push(`${c}_na`); baseForDerived.push(c);
      }

      // Filter unusable rows by target parse (regression) / transform constraints
      const rowRefs = [];
      const yAll = [];
      const yAllRaw = [];
      let droppedTargets = 0;

      for (const r of sampledRows) {
        const tv = getRowTargetValue(r, targetCol, task, targetTransform, meta);
        if (!tv) { droppedTargets++; continue; }
        rowRefs.push(r);
        yAll.push(tv.y);
        yAllRaw.push(tv.yRaw);
      }

      if (!rowRefs.length) {
        return {
          Xtrain: [], ytrain: [], Xtest: [], ytest: [],
          testRowRefs: [],
          trainRowRefs: [],
          featureNames, baseForDerived,
          pipeline: null, task,
          dropped: { unusableTargetRows: droppedTargets, unseenTestLabels: 0, sampledRows: sampledRows.length, usableRows: 0 }
        };
      }

      // Split BEFORE fitting preprocessors to avoid leakage
      let split;
      if (splitMode === "time" && splitDateCol) {
        const method = $("splitMethod").value || "cutoff";
        const cutoffStr = $("cutoffDate").value || "";
        let cutoffMs = null;
        if (method === "cutoff" && cutoffStr) {
          const d = new Date(`${cutoffStr}T00:00:00`);
          cutoffMs = Number.isFinite(d.getTime()) ? d.getTime() : null;
        }

        if (method === "cutoff" && cutoffMs !== null) {
          split = splitTimeBasedCutoff(rowRefs, splitDateCol, cutoffMs);
          if (!split.trainIdx.length || !split.testIdx.length) {
            split = splitTimeBased(rowRefs, splitDateCol, testFrac);
          }
        } else {
          split = splitTimeBased(rowRefs, splitDateCol, testFrac);
        }
      }
      else split = splitRandom(rowRefs.length, testFrac, seed);

      const trainRows = split.trainIdx.map(i => rowRefs[i]);
      const testRows = split.testIdx.map(i => rowRefs[i]);

      // Fit preprocessors on TRAIN only
      const contMedian = {};
      for (const c of contCols) {
        const vals = [];
        for (const r of trainRows) {
          const x = parseNum(r[c]);
          if (Number.isFinite(x)) vals.push(x);
        }
        contMedian[c] = median(vals);
      }

      const dateMedian = {};
      for (const c of dateCols) {
        const vals = [];
        for (const r of trainRows) {
          const d = parseDate(r[c]);
          if (d) vals.push(d.getTime());
        }
        dateMedian[c] = median(vals);
      }

      const catMapping = {};
      for (const c of catCols) {
        const m = new Map();
        m.set("#na#", 0);
        let id = 1;
        for (const r of trainRows) {
          const s = normStr(r[c]) || "#na#";
          if (!m.has(s)) m.set(s, id++);
        }
        catMapping[c] = Object.fromEntries(m.entries());
      }

      let targetMapping = null;
      let numTargetClasses = null;
      let normalizeTargetLabel = null;
      if (task === "classification") {
        const topN = APP.setup.multiClass?.topN || null;
        const dt = APP.setup.multiClass?.derivedTarget || null;
        const derivedActive = Boolean(dt?.enabled && dt.derivedCol && targetCol === dt.derivedCol);
        const enabled = Boolean(topN?.enabled) && !derivedActive;
        const keepN = Math.max(1, Math.floor(topN?.keep || 1));
        const rareLabel = normStr(topN?.rareLabel) || "RARE";

        let topSet = null;
        let hasRare = false;
        let kept = [];

        if (enabled) {
          const counts = new Map();
          for (const i of split.trainIdx) {
            const s = normStr(yAll[i]) || "#na#";
            if (s === "#na#") continue;
            counts.set(s, (counts.get(s) || 0) + 1);
          }

          const entries = Array.from(counts.entries())
            .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])));
          kept = entries.slice(0, Math.min(keepN, entries.length)).map(([k]) => k);
          topSet = new Set(kept);
          for (const y of yAll) {
            const s = normStr(y) || "#na#";
            if (s === "#na#") continue;
            if (!topSet.has(s)) { hasRare = true; break; }
          }
        }

        normalizeTargetLabel = (label) => {
          const s = normStr(label) || "#na#";
          if (s === "#na#") return "#na#";
          if (!topSet || topSet.has(s)) return s;
          return rareLabel;
        };

        const seen = new Map();
        seen.set("#na#", 0);
        let id = 1;

        if (topSet) {
          for (const s of kept) {
            if (!seen.has(s)) seen.set(s, id++);
          }
          if (hasRare && !seen.has(rareLabel)) seen.set(rareLabel, id++);
        }

        for (const i of split.trainIdx) {
          const s = normalizeTargetLabel(yAll[i]);
          if (!seen.has(s)) seen.set(s, id++);
        }
        targetMapping = Object.fromEntries(seen.entries());
        numTargetClasses = seen.size;
      }

      const pipeline = {
        schemaVersion: "1.3",
        createdAt: new Date().toISOString(),
        fileName: APP.raw.fileName,
        originalColumns: [...columns],
        includedColumns: [...includeCols],
        targetCol,
        task,
        targetTransform,
        procs: ["add_datepart", "FillMissing", "Categorify"],
        preprocess: {
          continuous: { cols: [...contCols], median: { ...contMedian } },
          categorical: { cols: [...catCols], mapping: JSON.parse(JSON.stringify(catMapping)), missingToken: "#na#", unknownId: 0 },
          date: { cols: [...dateCols], medianElapsed: { ...dateMedian }, parts: [...DATE_PARTS] }
        },
        derivedFeatureNames: [...featureNames],
        derivedFeatureBase: [...baseForDerived],
        target: { col: targetCol, mapping: targetMapping, numClasses: numTargetClasses },
        library: { name: "ml-random-forest", version: "2.1.0" },
        fittedOn: {
          splitMode,
          splitDateCol: splitDateCol || null,
          splitMethod: (splitMode === "time") ? ($("splitMethod").value || "cutoff") : "fraction",
          cutoffDate: (splitMode === "time") ? ($("cutoffDate").value || "") : "",
          nTrain: trainRows.length,
          nTest: testRows.length
        }
      };

      // Transform TRAIN
      const Xtrain = trainRows.map(r => transformRowToFeatures(r, pipeline));
      let ytrain;
      if (task === "regression") {
        ytrain = split.trainIdx.map(i => yAll[i]);
      } else {
        ytrain = split.trainIdx.map(i => {
          const s = normalizeTargetLabel ? normalizeTargetLabel(yAll[i]) : yAll[i];
          return (targetMapping[s] === undefined) ? 0 : targetMapping[s];
        });
      }

      // Transform TEST (drop unseen labels for classification)
      const Xtest = [];
      const ytest = [];
      const testRowRefs = [];
      let droppedUnseenTestLabels = 0;

      if (task === "regression") {
        for (const i of split.testIdx) {
          Xtest.push(transformRowToFeatures(rowRefs[i], pipeline));
          ytest.push(yAll[i]);
          testRowRefs.push(rowRefs[i]);
        }
      } else {
        for (const i of split.testIdx) {
          const label = normalizeTargetLabel ? normalizeTargetLabel(yAll[i]) : yAll[i];
          const id = targetMapping[label];
          if (id === undefined) { droppedUnseenTestLabels++; continue; }
          Xtest.push(transformRowToFeatures(rowRefs[i], pipeline));
          ytest.push(id);
          testRowRefs.push(rowRefs[i]);
        }
      }

      return {
        Xtrain, ytrain, Xtest, ytest, testRowRefs,
        trainRowRefs: trainRows,
        featureNames, baseForDerived,
        pipeline, task,
        dropped: {
          unusableTargetRows: droppedTargets,
          unseenTestLabels: droppedUnseenTestLabels,
          sampledRows: sampledRows.length,
          usableRows: rowRefs.length
        }
      };
    }

    // ----------------------------
    // Split
    // ----------------------------
    function splitRandom(n, testFrac, seed) {
      const rng = mulberry32(seed);
      const idx = Array.from({ length: n }, (_, i) => i);
      shuffleInPlace(idx, rng);
      const nTest = Math.max(1, Math.floor(n * testFrac));
      const testIdx = idx.slice(0, nTest);
      const trainIdx = idx.slice(nTest);
      return { trainIdx, testIdx };
    }

    function splitTimeBased(rowRefs, dateCol, testFrac) {
      const keys = rowRefs.map((r, i) => {
        const d = parseDate(r[dateCol]);
        const t = d ? d.getTime() : Number.NEGATIVE_INFINITY;
        return { i, t };
      });
      keys.sort((a,b)=>a.t-b.t);

      const n = keys.length;
      const nTest = Math.max(1, Math.floor(n * testFrac));
      const test = keys.slice(Math.max(0, n - nTest)).map(o => o.i);
      const train = keys.slice(0, Math.max(0, n - nTest)).map(o => o.i);
      return { trainIdx: train, testIdx: test };
    }

    function splitTimeBasedCutoff(rowRefs, dateCol, cutoffMs) {
      const trainIdx = [];
      const testIdx = [];
      for (let i = 0; i < rowRefs.length; i++) {
        const d = parseDate(rowRefs[i][dateCol]);
        const t = d ? d.getTime() : Number.NEGATIVE_INFINITY;
        if (t < cutoffMs) trainIdx.push(i);
        else testIdx.push(i);
      }
      return { trainIdx, testIdx };
    }

    function effectiveSplitMode() {
      const dateCols = APP.raw.columns.filter(c => APP.raw.colMeta[c]?.include && APP.raw.colMeta[c]?.inferredType === "date");
      const strategy = $("splitStrategy")?.value || "random";
      return (dateCols.length && strategy === "time") ? "time" : "random";
    }

    // ----------------------------
    // Charts
    // ----------------------------
    const FEATURE_COLORS = {
      continuous: { fill: "rgba(79, 152, 255, 0.75)", stroke: "rgba(79, 152, 255, 1)" },
      categorical: { fill: "rgba(182, 120, 255, 0.75)", stroke: "rgba(182, 120, 255, 1)" },
      date: { fill: "rgba(255, 170, 80, 0.75)", stroke: "rgba(255, 170, 80, 1)" },
      datepart: { fill: "rgba(255, 170, 80, 0.75)", stroke: "rgba(255, 170, 80, 1)" },
      other: { fill: "rgba(160, 175, 205, 0.60)", stroke: "rgba(160, 175, 205, 0.90)" },
    };

    function baseTypeOfColumn(col) {
      const t = APP.raw.colMeta?.[col]?.inferredType;
      if (t === "continuous" || t === "categorical" || t === "date") return t;
      return "other";
    }

    function buildDerivedTypeByFeature(featureNames, baseForDerived) {
      const map = {};
      for (let i = 0; i < featureNames.length; i++) {
        const feat = featureNames[i];
        const base = baseForDerived[i] || feat;
        const baseType = baseTypeOfColumn(base);
        map[feat] = (baseType === "date") ? "datepart" : baseType;
      }
      return map;
    }

    function colorsForFiLabels(labels, mode) {
      const backgroundColor = [];
      const borderColor = [];
      const derivedMap = APP.train.derivedTypeByFeature || {};
      for (const name of labels) {
        const t = (mode === "derived")
          ? (derivedMap[name] || baseTypeOfColumn(name))
          : baseTypeOfColumn(name);
        const c = FEATURE_COLORS[t] || FEATURE_COLORS.other;
        backgroundColor.push(c.fill);
        borderColor.push(c.stroke);
      }
      return { backgroundColor, borderColor };
    }

    function destroyChart(ch) {
      if (ch) { try { ch.destroy(); } catch {} }
      return null;
    }

    function clearSecondaryViz() {
      APP.ui.charts.secondary = destroyChart(APP.ui.charts.secondary);
      const m = $("secondaryMatrix");
      if (m) m.innerHTML = "";
      hide($("secondaryMatrix"));
      show($("secondaryChart"));
      hide($("classFocusRow"));
      const sel = $("classFocus");
      if (sel) sel.onchange = null;
      if ($("classMetrics")) $("classMetrics").textContent = "‚Äî";
    }

    function renderFIChart(pairs, titleLabel, mode = "base") {
      const top = pairs.slice(0, 20);
      const labels = top.map(x => x.name);
      const data = top.map(x => x.imp);
      const colors = colorsForFiLabels(labels, mode);

      const ctx = $("fiChart").getContext("2d");
      APP.ui.charts.fi = destroyChart(APP.ui.charts.fi);

      APP.ui.charts.fi = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            label: titleLabel || "importance",
            data,
            backgroundColor: colors.backgroundColor,
            borderColor: colors.borderColor,
            borderWidth: 1,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: "y",
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { color: "rgba(234,240,255,0.75)" }, grid: { color: "rgba(234,240,255,0.08)" } },
            y: { ticks: { color: "rgba(234,240,255,0.75)" }, grid: { display: false } }
          }
        }
      });
    }

    function renderShiftFIChart(pairs) {
      const top = (pairs || []).slice(0, 20);
      const labels = top.map(x => x.name);
      const data = top.map(x => x.imp);
      const colors = colorsForFiLabels(labels, "base");

      const ctx = $("shiftFiChart").getContext("2d");
      APP.ui.charts.shift = destroyChart(APP.ui.charts.shift);

      APP.ui.charts.shift = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            label: "shift importance",
            data,
            backgroundColor: colors.backgroundColor,
            borderColor: colors.borderColor,
            borderWidth: 1,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: "y",
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { color: "rgba(234,240,255,0.75)" }, grid: { color: "rgba(234,240,255,0.08)" } },
            y: { ticks: { color: "rgba(234,240,255,0.75)" }, grid: { display: false } }
          }
        }
      });
    }

    function sampleRows(rows, maxRows, seed) {
      const n = rows.length;
      if (n <= maxRows) return { rows, idx: Array.from({ length: n }, (_, i) => i) };
      const rng = mulberry32(seed >>> 0);
      const idx = Array.from({ length: n }, (_, i) => i);
      shuffleInPlace(idx, rng);
      const pick = idx.slice(0, maxRows);
      return { rows: pick.map(i => rows[i]), idx: pick };
    }

    function buildShiftPipelineFromRows(basePipeline, rowsAll) {
      const contCols = basePipeline.preprocess.continuous.cols;
      const catCols = basePipeline.preprocess.categorical.cols;
      const dateCols = basePipeline.preprocess.date.cols;
      const DATE_PARTS = basePipeline.preprocess.date.parts;

      const contMedian = {};
      for (const c of contCols) {
        const vals = [];
        for (const r of rowsAll) {
          const x = parseNum(r[c]);
          if (Number.isFinite(x)) vals.push(x);
        }
        contMedian[c] = median(vals);
      }

      const dateMedian = {};
      for (const c of dateCols) {
        const vals = [];
        for (const r of rowsAll) {
          const d = parseDate(r[c]);
          if (d) vals.push(d.getTime());
        }
        dateMedian[c] = median(vals);
      }

      const catMapping = {};
      for (const c of catCols) {
        const m = new Map();
        m.set("#na#", 0);
        let id = 1;
        for (const r of rowsAll) {
          const s = normStr(r[c]) || "#na#";
          if (!m.has(s)) m.set(s, id++);
        }
        catMapping[c] = Object.fromEntries(m.entries());
      }

      return {
        preprocess: {
          continuous: { cols: [...contCols], median: { ...contMedian } },
          categorical: { cols: [...catCols], mapping: JSON.parse(JSON.stringify(catMapping)), missingToken: "#na#", unknownId: 0 },
          date: { cols: [...dateCols], medianElapsed: { ...dateMedian }, parts: [...DATE_PARTS] }
        }
      };
    }

    async function computeShiftDiagnostics({ trainRows, testRows, pipeline, featureNames, baseForDerived, seed, signal }) {
      // Fit procs on combined (train+test) rows to avoid artificial shift from "unknown category" encoding.
      const nTrain = trainRows.length;
      const nTest = testRows.length;
      const total = nTrain + nTest;
      if (!nTrain || !nTest || !total) return null;

      // IMPORTANT: Balance classes 50/50; otherwise accuracy is dominated by class imbalance
      // (e.g., with a 90/10 train/test split, a dumb classifier gets 0.90 accuracy).
      const maxTotal = 20000;
      const perClass = Math.max(1, Math.min(Math.floor(maxTotal / 2), nTrain, nTest));

      const trainS = sampleRows(trainRows, perClass, seed + 101);
      const testS = sampleRows(testRows, perClass, seed + 202);
      const rowsAll = trainS.rows.concat(testS.rows);

      const shiftPipe = buildShiftPipelineFromRows(pipeline, rowsAll);
      const X = rowsAll.map(r => transformRowToFeatures(r, shiftPipe));
      const y = new Array(trainS.rows.length).fill(0).concat(new Array(testS.rows.length).fill(1));

      const trees = 120;
      const shiftModel = new RandomForestClassifier({
        seed: Math.floor(seed + 777),
        nEstimators: trees,
        maxFeatures: 1.0,
        replacement: false,
        useSampleBagging: true,
      });

      const info = await trainForestWithProgress(shiftModel, X, y, {
        onProgress: () => {},
        signal: signal || null,
      });

      const oobPred = info?.oobPred || null;
      let oobAcc = null;
      let oobBalAcc = null;
      let oobF1 = null;
      let oobCovered = 0;
      if (oobPred && oobPred.length === y.length) {
        const filtered = filterPaired(y.map(v => Number(v)), oobPred.map(v => (v === null ? null : Number(v))));
        oobCovered = filtered.yTrue.length;
        if (filtered.yTrue.length) {
          oobAcc = accuracy(filtered.yTrue, filtered.yPred);
          oobBalAcc = balancedAccuracy(filtered.yTrue, filtered.yPred, 2);
          oobF1 = f1Macro(filtered.yTrue, filtered.yPred, 2);
        }
      }

      let fi = null;
      try { fi = shiftModel.featureImportance(); } catch { fi = null; }
      const fiBase = (fi && fi.length === featureNames.length)
        ? aggregateFI(fi, featureNames, baseForDerived)
        : [];

      return {
        oobAcc,
        oobBalAcc,
        oobF1,
        oobCovered,
        nTotal: y.length,
        nTrainUsed: trainS.rows.length,
        nTestUsed: testS.rows.length,
        fiBase,
      };
    }

    function renderRegressionScatter(yTrue, yPred) {
      clearSecondaryViz();

      const n = yTrue.length;
      const maxPts = Math.min(2000, n);
      const rng = mulberry32(1337);
      const idx = Array.from({ length: n }, (_, i) => i);
      shuffleInPlace(idx, rng);
      const pick = idx.slice(0, maxPts);

      const pts = pick.map(i => ({ x: yTrue[i], y: yPred[i] }));

      // Reference line y = x across the visible range
      let minV = Infinity, maxV = -Infinity;
      for (let i = 0; i < pts.length; i++) {
        const x = pts[i].x, y = pts[i].y;
        if (Number.isFinite(x)) { if (x < minV) minV = x; if (x > maxV) maxV = x; }
        if (Number.isFinite(y)) { if (y < minV) minV = y; if (y > maxV) maxV = y; }
      }
      if (!Number.isFinite(minV) || !Number.isFinite(maxV) || minV === maxV) {
        minV = 0; maxV = 1;
      }

      const refLine = [{ x: minV, y: minV }, { x: maxV, y: maxV }];

      const ctx = $("secondaryChart").getContext("2d");
      APP.ui.charts.secondary = destroyChart(APP.ui.charts.secondary);

      APP.ui.charts.secondary = new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: [
            { label: "pred vs true", data: pts, pointRadius: 2 },
            {
              type: "line",
              label: "y = x",
              data: refLine,
              pointRadius: 0,
              borderWidth: 1,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { title: { display: true, text: "true" }, ticks: { color: "rgba(234,240,255,0.75)" }, grid: { color: "rgba(234,240,255,0.08)" } },
            y: { title: { display: true, text: "pred" }, ticks: { color: "rgba(234,240,255,0.75)" }, grid: { color: "rgba(234,240,255,0.08)" } }
          }
        }
      });
    }

    function renderConfusionMatrix(yTrue, yPred, invMap, maxClasses = 10) {
      clearSecondaryViz();
      hide($("secondaryChart"));
      show($("secondaryMatrix"));
      show($("classFocusRow"));

      const labelOf = (c) => (invMap && invMap[c] !== undefined) ? String(invMap[c]) : String(c);

      const support = new Map();
      for (const t of yTrue) support.set(t, (support.get(t) || 0) + 1);
      const classes = Array.from(support.keys()).sort((a, b) => (support.get(b) || 0) - (support.get(a) || 0));
      const shown = classes.slice(0, Math.min(maxClasses, classes.length));

      const idx = new Map(shown.map((c, i) => [c, i]));
      const k = shown.length;
      const mat = Array.from({ length: k }, () => new Array(k).fill(0));
      const rowSum = new Array(k).fill(0);

      for (let i = 0; i < yTrue.length; i++) {
        const ti = idx.get(yTrue[i]);
        const pi = idx.get(yPred[i]);
        if (ti === undefined || pi === undefined) continue;
        mat[ti][pi] += 1;
        rowSum[ti] += 1;
      }

      let maxFrac = 0;
      for (let r = 0; r < k; r++) {
        const denom = Math.max(1, rowSum[r]);
        for (let c = 0; c < k; c++) maxFrac = Math.max(maxFrac, mat[r][c] / denom);
      }
      maxFrac = Math.max(1e-9, maxFrac);

      const head = [
        `<th class="stickyCol">true \\\\ pred</th>`,
        ...shown.map(c => `<th>${escapeHtml(labelOf(c))}</th>`),
      ].join("");

      const rows = [];
      for (let r = 0; r < k; r++) {
        const trLabel = escapeHtml(labelOf(shown[r]));
        const denom = Math.max(1, rowSum[r]);
        const cells = [];
        cells.push(`<td class="stickyCol">${trLabel}</td>`);
        for (let c = 0; c < k; c++) {
          const v = mat[r][c];
          const frac = v / denom;
          const a = 0.10 + 0.74 * Math.pow(frac / maxFrac, 0.85);
          const isDiag = (r === c);
          const cls = `cmCell${isDiag ? " cmDiag" : ""}`;
          const title = `${labelOf(shown[r])} ‚Üí ${labelOf(shown[c])}: ${v} (${(frac * 100).toFixed(1)}%)`;
          cells.push(`<td class="${cls}" title="${escapeHtml(title)}" style="background: rgba(139,92,246,${a.toFixed(3)});">${v}</td>`);
        }
        rows.push(`<tr>${cells.join("")}</tr>`);
      }

      $("secondaryMatrix").innerHTML = `<table class="cm"><thead><tr>${head}</tr></thead><tbody>${rows.join("")}</tbody></table>`;

      const sel = $("classFocus");
      const cur = sel.value;
      const opts = [`<option value="">(all classes)</option>`]
        .concat(shown.map(c => `<option value="${escapeHtml(String(c))}">${escapeHtml(labelOf(c))}</option>`));
      sel.innerHTML = opts.join("");
      if (cur) sel.value = cur;

      const updateMetrics = () => {
        const v = sel.value;
        if (!v) { $("classMetrics").textContent = "Select a class for precision/recall/micro-F1 (one-vs-rest)."; return; }
        const clsId = Number(v);
        let tp = 0, fp = 0, fn = 0, supportN = 0;
        for (let i = 0; i < yTrue.length; i++) {
          const t = yTrue[i], p = yPred[i];
          if (t === clsId) { supportN++; if (p === clsId) tp++; else fn++; }
          else { if (p === clsId) fp++; }
        }
        const prec = tp / Math.max(1, tp + fp);
        const rec = tp / Math.max(1, tp + fn);
        const f1 = (prec + rec) ? (2 * prec * rec) / (prec + rec) : 0;
        $("classMetrics").innerHTML =
          `Precision <span class="mono">${formatNum(prec, 4)}</span> ¬∑ ` +
          `Recall <span class="mono">${formatNum(rec, 4)}</span> ¬∑ ` +
          `Micro-F1 <span class="mono">${formatNum(f1, 4)}</span> ¬∑ ` +
          `Support <span class="mono">${supportN}</span>`;
      };
      sel.onchange = updateMetrics;
      updateMetrics();
    }

    // ----------------------------
    // Feature importance aggregation
    // ----------------------------
    function aggregateFI(fiDerived, featureNames, baseForDerived) {
      const agg = new Map();
      for (let i = 0; i < fiDerived.length; i++) {
        const base = baseForDerived[i] || featureNames[i] || `f${i}`;
        agg.set(base, (agg.get(base) || 0) + (Number.isFinite(fiDerived[i]) ? fiDerived[i] : 0));
      }
      return Array.from(agg.entries())
        .map(([name, imp]) => ({ name, imp }))
        .sort((a,b)=>b.imp-a.imp);
    }

    // ----------------------------
    // Prune ‚Üí retrain (feature selection loop)
    // ----------------------------
    function currentIncludedFeatureCols() {
      const targetCol = APP.raw.targetCol;
      const meta = APP.raw.colMeta || {};
      return APP.raw.columns.filter(c => c !== targetCol && meta[c]?.include);
    }

    function normalizeFi(fiBase) {
      const xs = (fiBase || [])
        .filter(x => x && typeof x.name === "string" && Number.isFinite(x.imp))
        .map(x => ({ name: x.name, imp: Math.max(0, Number(x.imp)) }));
      const sum = xs.reduce((a, x) => a + x.imp, 0);
      if (!(sum > 0)) return [];
      let cum = 0;
      return xs.map(x => {
        const frac = x.imp / sum;
        cum += frac;
        return { name: x.name, imp: x.imp, frac, cum };
      });
    }

    const PRUNE_SHOW_THRESHOLD = 0.002;

    function applyExclusionsAndRetrain({ dropCols, reason }) {
      const cols = (dropCols || []).filter(c => c && c !== APP.raw.targetCol);
      if (!cols.length) return;
      if (APP.ui.training.isTraining) return;

      APP.ui.pruneUndoExcluded = new Set(APP.setup.excluded);
      APP.ui.pruneUndoReason = reason || "prune";
      APP.ui.pruneJustApplied = true;

      for (const c of cols) APP.setup.excluded.add(c);
      syncHiddenTypingLists();
      recomputeColumnMeta();
      refreshSplitDateCol();
      syncSetupUI();
      renderColumnTable();
      syncButtons();

      gotoStep(2);
      setTimeout(() => trainModel(), 50);
    }

    function undoLastPrune() {
      if (!APP.ui.pruneUndoExcluded) return;
      if (APP.ui.training.isTraining) return;
      APP.setup.excluded = new Set(APP.ui.pruneUndoExcluded);
      APP.ui.pruneUndoExcluded = null;
      APP.ui.pruneUndoReason = "";
      APP.ui.pruneJustApplied = false;
      syncHiddenTypingLists();
      recomputeColumnMeta();
      refreshSplitDateCol();
      syncSetupUI();
      renderColumnTable();
      syncButtons();
      updatePruneMiniUi();
    }

    function updatePruneMiniUi() {
      const hasModel = Boolean(APP.train.model && APP.train.pipeline);
      $("pruneUndoBtn").disabled = !APP.ui.pruneUndoExcluded;

      if (!hasModel) {
        hide($("pruneImpRow"));
        $("pruneImpBtn").disabled = true;
        $("pruneShiftTopBtn").disabled = true;
        $("pruneMiniHint").textContent = "Train a model to enable pruning.";
        return;
      }

      const fiNorm = normalizeFi(APP.train.fiBase);
      const hasFi = fiNorm.length > 0;
      const includedCols = currentIncludedFeatureCols();
      const hasLow = hasFi && fiNorm.some(x => includedCols.includes(x.name) && x.frac < PRUNE_SHOW_THRESHOLD);
      if (hasLow) show($("pruneImpRow"));
      else hide($("pruneImpRow"));
      $("pruneImpBtn").disabled = !(hasFi && hasLow);

      const shift = APP.train.shift;
      const shiftScore = shift?.oobBalAcc ?? shift?.oobAcc ?? null;
      const shiftReady = (shiftScore !== null) && shiftScore >= 0.75 && Array.isArray(shift?.fiBase) && normalizeFi(shift.fiBase).length;
      $("pruneShiftTopBtn").disabled = !shiftReady;

      const included = currentIncludedFeatureCols().length;
      const excluded = APP.setup.excluded?.size || 0;
      const shiftTxt = (shiftScore === null) ? "shift: n/a" : `shift=${formatNum(shiftScore, 3)}`;
      $("pruneMiniHint").textContent = `Included=${included} ¬∑ Excluded=${excluded} ¬∑ ${shiftTxt}`;
    }

    // ----------------------------
    // Predictions explorer
    // ----------------------------
    function updateUncertaintyPills() {
      const task = APP.train.pipeline?.task || "";
      const metric = (task === "regression") ? "tree std" : "1 - vote_frac";

      const p = $("uncertaintyPill");
      if (!APP.train.model || !APP.train.pipeline) {
        p.className = "pill";
        p.textContent = "Uncertainty: ‚Äî";
        p.title = "";
        return;
      }

      const st = APP.train.uncertaintyStatus || "none";
      if (st === "running") {
        p.className = "pill warn";
        p.textContent = `Uncertainty: computing (${metric})`;
        p.title = "Computing how much the trees disagree for each test row.";
      } else if (st === "ready") {
        p.className = "pill good";
        p.textContent = `Uncertainty: ready (${metric})`;
        p.title = "Higher means less agreement across trees (less confidence).";
      } else if (st === "error") {
        p.className = "pill bad";
        p.textContent = "Uncertainty: failed";
        p.title = APP.train.uncertaintyError || "";
      } else {
        p.className = "pill";
        p.textContent = "Uncertainty: ‚Äî";
        p.title = "";
      }
    }

    async function computeTreeDisagreementUncertainty({ model, X, pipeline, ensemblePred, signal }) {
      if (!model || !pipeline || !Array.isArray(X)) throw new Error("Missing model/pipeline/X.");
      const task = pipeline.task;
      const nRows = X.length;

      if (signal?.aborted) throw new DOMException("Aborted", "AbortError");

      const tryPredictionValues = async () => {
        if (typeof model.predictionValues !== "function") return null;
        let predValues;
        try {
          predValues = model.predictionValues(X);
        } catch (e) {
          try {
            predValues = model.predictionValues(new Matrix(X));
          } catch {
            throw e;
          }
        }
        if (!Array.isArray(predValues) || predValues.length === 0) throw new Error("predictionValues() returned no data.");
        if (!Array.isArray(predValues[0])) throw new Error("predictionValues() returned unexpected shape.");

        const n0 = predValues.length;
        const n1 = Array.isArray(predValues[0]) ? predValues[0].length : 0;
        const shape = (n0 === nRows) ? "rowMajor"
          : (n1 === nRows) ? "treeMajor"
          : "unknown";
        if (shape === "unknown") throw new Error(`predictionValues() shape mismatch (got ${n0}x${n1}, expected ${nRows} rows).`);
        const nTrees = (shape === "rowMajor") ? (predValues[0]?.length || 0) : predValues.length;
        if (!nTrees) throw new Error("predictionValues() reported 0 trees.");

        if (task === "regression") {
          const mean = new Float64Array(nRows);
          const m2 = new Float64Array(nRows);
          const count = new Uint16Array(nRows);

          if (shape === "rowMajor") {
            for (let i = 0; i < nRows; i++) {
              if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
              const row = predValues[i];
              if (!Array.isArray(row) || !row.length) continue;
              let c = 0;
              let mu = 0;
              let m2i = 0;
              for (let t = 0; t < row.length; t++) {
                const x = Number(row[t]);
                if (!Number.isFinite(x)) continue;
                c++;
                const d1 = x - mu;
                mu += d1 / c;
                const d2 = x - mu;
                m2i += d1 * d2;
              }
              count[i] = Math.min(65535, c);
              mean[i] = mu;
              m2[i] = m2i;
              if (i % 4000 === 0) await new Promise(r => setTimeout(r, 0));
            }
          } else {
            for (let t = 0; t < predValues.length; t++) {
              if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
              const tree = predValues[t];
              if (!Array.isArray(tree) || tree.length !== nRows) throw new Error("predictionValues() tree length mismatch.");
              for (let i = 0; i < nRows; i++) {
                const x = Number(tree[i]);
                if (!Number.isFinite(x)) continue;
                const c = (count[i] + 1);
                count[i] = c;
                const d1 = x - mean[i];
                mean[i] += d1 / c;
                const d2 = x - mean[i];
                m2[i] += d1 * d2;
              }
              if (t % 5 === 0) await new Promise(r => setTimeout(r, 0));
            }
          }

          const treeStd = new Float64Array(nRows);
          const uncertainty = new Float64Array(nRows);
          for (let i = 0; i < nRows; i++) {
            const c = count[i];
            const v = (c > 1) ? (m2[i] / (c - 1)) : 0;
            const s = Number.isFinite(v) && v > 0 ? Math.sqrt(v) : 0;
            treeStd[i] = s;
            uncertainty[i] = s;
          }

          return {
            uncertainty: Array.from(uncertainty),
            details: { treeStd: Array.from(treeStd), treeMean: Array.from(mean), treeCount: Array.from(count) },
          };
        }

        if (task === "classification") {
          const numClasses = pipeline.target?.numClasses || null;
          const voteFracMode = new Float64Array(nRows);
          const voteMargin = new Float64Array(nRows);
          const voteEntropy = new Float64Array(nRows);
          const uncertainty = new Float64Array(nRows);

          const canDenseCount = Number.isFinite(numClasses) && numClasses > 0 && numClasses <= 200 && (nRows * numClasses) <= 10_000_000;
          if (canDenseCount && shape === "treeMajor") {
            const k = numClasses;
            const counts = new Uint16Array(nRows * k);
            for (let t = 0; t < predValues.length; t++) {
              if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
              const tree = predValues[t];
              if (!Array.isArray(tree) || tree.length !== nRows) throw new Error("predictionValues() tree length mismatch.");
              for (let i = 0; i < nRows; i++) {
                const cls = Number(tree[i]);
                if (!Number.isFinite(cls)) continue;
                const c = Math.floor(cls);
                if (c < 0 || c >= k) continue;
                const idx = i * k + c;
                if (counts[idx] < 65535) counts[idx]++;
              }
              if (t % 5 === 0) await new Promise(r => setTimeout(r, 0));
            }
            for (let i = 0; i < nRows; i++) {
              let maxC = 0, secondC = 0, sumC = 0;
              let ent = 0;
              const base = i * k;
              for (let c = 0; c < k; c++) {
                const v = counts[base + c];
                sumC += v;
                if (v >= maxC) { secondC = maxC; maxC = v; }
                else if (v > secondC) secondC = v;
              }
              const denom = Math.max(1, sumC);
              for (let c = 0; c < k; c++) {
                const v = counts[base + c];
                if (!v) continue;
                const p = v / denom;
                ent += -p * Math.log(p);
              }
              const frac = maxC / denom;
              const mar = (maxC - secondC) / denom;
              const entNorm = (k > 1) ? (ent / Math.log(k)) : 0;
              voteFracMode[i] = frac;
              voteMargin[i] = mar;
              voteEntropy[i] = entNorm;
              uncertainty[i] = 1 - frac;
            }
          } else {
            throw new Error("predictionValues() classification fallback unsupported for this shape/classes.");
          }

          return {
            uncertainty: Array.from(uncertainty),
            details: {
              voteFracMode: Array.from(voteFracMode),
              voteMargin: Array.from(voteMargin),
              voteEntropy: Array.from(voteEntropy),
              nTrees,
            }
          };
        }

        throw new Error(`Unknown task: ${task}`);
      };

      const tryEstimators = async () => {
        const est = model.estimators;
        if (!Array.isArray(est) || !est.length) throw new Error("Model has no estimators.");
        const nTrees = est.length;
        let Xm = null;
        const treePredict = (t) => {
          try {
            return est[t].predict(X);
          } catch (e) {
            try {
              if (!Xm) Xm = new Matrix(X);
              return est[t].predict(Xm);
            } catch {
              throw e;
            }
          }
        };

        if (task === "regression") {
          const mean = new Float64Array(nRows);
          const m2 = new Float64Array(nRows);
          const count = new Uint16Array(nRows);

          for (let t = 0; t < nTrees; t++) {
            if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
            const treePred = treePredict(t);
            if (!Array.isArray(treePred) || treePred.length !== nRows) throw new Error("Estimator prediction length mismatch.");
            for (let i = 0; i < nRows; i++) {
              const x = Number(treePred[i]);
              if (!Number.isFinite(x)) continue;
              const c = (count[i] + 1);
              count[i] = c;
              const d1 = x - mean[i];
              mean[i] += d1 / c;
              const d2 = x - mean[i];
              m2[i] += d1 * d2;
            }
            if (t % 5 === 0) await new Promise(r => setTimeout(r, 0));
          }

          const treeStd = new Float64Array(nRows);
          const uncertainty = new Float64Array(nRows);
          for (let i = 0; i < nRows; i++) {
            const c = count[i];
            const v = (c > 1) ? (m2[i] / (c - 1)) : 0;
            const s = Number.isFinite(v) && v > 0 ? Math.sqrt(v) : 0;
            treeStd[i] = s;
            uncertainty[i] = s;
          }

          return {
            uncertainty: Array.from(uncertainty),
            details: { treeStd: Array.from(treeStd), treeMean: Array.from(mean), treeCount: Array.from(count) },
          };
        }

        if (task === "classification") {
          const numClasses = pipeline.target?.numClasses || null;
          const canDenseCount = Number.isFinite(numClasses) && numClasses > 0 && numClasses <= 200 && (nRows * numClasses) <= 10_000_000;

          const voteFracMode = new Float64Array(nRows);
          const voteMargin = new Float64Array(nRows);
          const voteEntropy = new Float64Array(nRows);
          const uncertainty = new Float64Array(nRows);

          if (canDenseCount) {
            const k = numClasses;
            const counts = new Uint16Array(nRows * k);
            for (let t = 0; t < nTrees; t++) {
              if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
              const treePred = treePredict(t);
              if (!Array.isArray(treePred) || treePred.length !== nRows) throw new Error("Estimator prediction length mismatch.");
              for (let i = 0; i < nRows; i++) {
                const cls = Number(treePred[i]);
                if (!Number.isFinite(cls)) continue;
                const c = Math.floor(cls);
                if (c < 0 || c >= k) continue;
                const idx = i * k + c;
                if (counts[idx] < 65535) counts[idx]++;
              }
              if (t % 5 === 0) await new Promise(r => setTimeout(r, 0));
            }

            for (let i = 0; i < nRows; i++) {
              let maxC = 0, secondC = 0, sumC = 0;
              let ent = 0;
              const base = i * k;
              for (let c = 0; c < k; c++) {
                const v = counts[base + c];
                sumC += v;
                if (v >= maxC) { secondC = maxC; maxC = v; }
                else if (v > secondC) secondC = v;
              }
              const denom = Math.max(1, sumC);
              for (let c = 0; c < k; c++) {
                const v = counts[base + c];
                if (!v) continue;
                const p = v / denom;
                ent += -p * Math.log(p);
              }
              const frac = maxC / denom;
              const mar = (maxC - secondC) / denom;
              const entNorm = (k > 1) ? (ent / Math.log(k)) : 0;
              voteFracMode[i] = frac;
              voteMargin[i] = mar;
              voteEntropy[i] = entNorm;
              uncertainty[i] = 1 - frac;
            }

            return {
              uncertainty: Array.from(uncertainty),
              details: {
                voteFracMode: Array.from(voteFracMode),
                voteMargin: Array.from(voteMargin),
                voteEntropy: Array.from(voteEntropy),
                nTrees,
              }
            };
          }

          // Fallback for large/unknown class counts: agreement with ensemble prediction.
          if (!Array.isArray(ensemblePred) || ensemblePred.length !== nRows) throw new Error("Need ensemblePred for classification uncertainty fallback.");
          const agree = new Uint16Array(nRows);
          for (let t = 0; t < nTrees; t++) {
            if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
            const treePred = treePredict(t);
            if (!Array.isArray(treePred) || treePred.length !== nRows) throw new Error("Estimator prediction length mismatch.");
            for (let i = 0; i < nRows; i++) {
              if (Number(treePred[i]) === Number(ensemblePred[i])) agree[i]++;
            }
            if (t % 5 === 0) await new Promise(r => setTimeout(r, 0));
          }
          for (let i = 0; i < nRows; i++) {
            const frac = agree[i] / Math.max(1, nTrees);
            voteFracMode[i] = frac;
            voteMargin[i] = NaN;
            voteEntropy[i] = NaN;
            uncertainty[i] = 1 - frac;
          }
          return {
            uncertainty: Array.from(uncertainty),
            details: { voteFracMode: Array.from(voteFracMode), voteMargin: null, voteEntropy: null, nTrees },
          };
        }

        throw new Error(`Unknown task: ${task}`);
      };

      try {
        const out = await tryPredictionValues();
        if (out) return out;
      } catch (e) {
        // Fall through to estimator-based computation.
      }
      return await tryEstimators();
    }

    function currentPredView() {
      const pageSize = Math.max(10, Math.floor(parseNum($("pageSize").value) || 50));
      const filter = normStr($("predFilter").value).toLowerCase();
      APP.ui.predFilter = filter;

      const yTrueDisp = APP.train.pipeline.task === "classification"
        ? APP.train.yTest.map(v => String(APP.train.pipeline.targetInvMapping?.[v] ?? v))
        : APP.train.yTest.map(v => String(v));

      const yPredDisp = APP.train.pipeline.task === "classification"
        ? APP.train.yPredLabel
        : APP.train.yPred.map(v => String(v));

      const idxAll = Array.from({ length: APP.train.yTest.length }, (_, i) => i);
      const idxFiltered = filter
        ? idxAll.filter(i => (yTrueDisp[i] || "").toLowerCase().includes(filter) || (yPredDisp[i] || "").toLowerCase().includes(filter))
        : idxAll;

      const n = idxFiltered.length;
      const maxPage = Math.max(0, Math.ceil(n / pageSize) - 1);
      APP.ui.predPage = Math.max(0, Math.min(APP.ui.predPage, maxPage));

      const start = APP.ui.predPage * pageSize;
      const end = Math.min(n, start + pageSize);
      const pageIdx = idxFiltered.slice(start, end);

      return { pageSize, filter, idxFiltered, pageIdx, n, start, end, maxPage, yTrueDisp, yPredDisp };
    }

    function renderPredTable() {
      const targetCol = APP.raw.targetCol;
      const featureCols = APP.raw.columns.filter(c => c !== targetCol);
      const colsShown = featureCols.slice(0, Math.min(10, featureCols.length));

      const view = currentPredView();

      const headCols = ["__y_true__", "__y_pred__", "__err__", "__abs_err__", "__uncertainty__"].concat(colsShown);
      const thead = "<thead><tr>" + headCols.map(c => `<th>${escapeHtml(c)}</th>`).join("") + "</tr></thead>";

      const rowsHtml = view.pageIdx.map(i => {
        const r = APP.train.testRowRefs[i];

        const yt = view.yTrueDisp[i];
        const yp = view.yPredDisp[i];

        const err = APP.train.err[i];
        const absErr = APP.train.absErr[i];
        const unc = Array.isArray(APP.train.uncertainty) ? APP.train.uncertainty[i] : null;

        const cells = [
          `<td class="mono">${escapeHtml(String(yt))}</td>`,
          `<td class="mono">${escapeHtml(String(yp))}</td>`,
          `<td class="mono">${escapeHtml(String(Number.isFinite(err) ? formatNum(err, 6) : err))}</td>`,
          `<td class="mono">${escapeHtml(String(Number.isFinite(absErr) ? formatNum(absErr, 6) : absErr))}</td>`,
          `<td class="mono">${escapeHtml(String(Number.isFinite(unc) ? formatNum(unc, 6) : ""))}</td>`,
        ];

        for (const c of colsShown) {
          cells.push(`<td>${escapeHtml(truncate(normStr(r[c]) || "", 200))}</td>`);
        }

        return `<tr>${cells.join("")}</tr>`;
      }).join("");

      $("predTable").innerHTML = thead + `<tbody>${rowsHtml}</tbody>`;
    }

    function renderPredInsights() {
      if (!APP.train.model || !APP.train.pipeline) return;
      updateUncertaintyPills();

      const targetCol = APP.raw.targetCol;
      const featureCols = APP.raw.columns.filter(c => c !== targetCol);
      const colsShown = featureCols.slice(0, Math.min(6, featureCols.length));

      const topK = Math.max(10, Math.floor(parseNum($("predTopK").value) || 30));
      const n = APP.train.testRowRefs.length;

      const idxAll = Array.from({ length: n }, (_, i) => i);
      const uncReady = Array.isArray(APP.train.uncertainty) && APP.train.uncertainty.length === n;
      const idxWorst = idxAll
        .slice()
        .sort((a, b) => {
          const da = APP.train.absErr[a] || 0;
          const db = APP.train.absErr[b] || 0;
          if (db !== da) return db - da;
          if (!uncReady) return 0;
          return (APP.train.uncertainty[b] || 0) - (APP.train.uncertainty[a] || 0);
        })
        .slice(0, Math.min(topK, n));

      const idxUnc = uncReady
        ? idxAll.slice().sort((a, b) => (APP.train.uncertainty[b] || 0) - (APP.train.uncertainty[a] || 0)).slice(0, Math.min(topK, n))
        : [];

      const task = APP.train.pipeline.task;
      const inv = APP.train.pipeline.targetInvMapping;
      const yTrueDisp = (task === "classification")
        ? APP.train.yTest.map(v => String(inv?.[v] ?? v))
        : APP.train.yTest.map(v => String(v));
      const yPredDisp = (task === "classification")
        ? APP.train.yPredLabel
        : APP.train.yPred.map(v => String(v));

      const renderRankTable = (tableId, idx, emptyText) => {
        const headCols = ["i", "y_true", "y_pred", "err", "abs_err", "uncertainty"].concat(colsShown);
        const thead = "<thead><tr>" + headCols.map(c => `<th>${escapeHtml(c)}</th>`).join("") + "</tr></thead>";
        if (!idx.length) {
          $(tableId).innerHTML = thead + `<tbody><tr><td colspan="${headCols.length}" class="muted2">${escapeHtml(emptyText)}</td></tr></tbody>`;
          return;
        }
        const rowsHtml = idx.map(i => {
          const r = APP.train.testRowRefs[i];
          const yt = yTrueDisp[i];
          const yp = yPredDisp[i];
          const err = APP.train.err[i];
          const absErr = APP.train.absErr[i];
          const unc = uncReady ? APP.train.uncertainty[i] : null;
          const cells = [
            `<td class="mono">${i}</td>`,
            `<td class="mono">${escapeHtml(String(yt))}</td>`,
            `<td class="mono">${escapeHtml(String(yp))}</td>`,
            `<td class="mono">${escapeHtml(String(Number.isFinite(err) ? formatNum(err, 6) : err))}</td>`,
            `<td class="mono">${escapeHtml(String(Number.isFinite(absErr) ? formatNum(absErr, 6) : absErr))}</td>`,
            `<td class="mono">${escapeHtml(String(Number.isFinite(unc) ? formatNum(unc, 6) : ""))}</td>`,
          ];
          for (const c of colsShown) {
            cells.push(`<td>${escapeHtml(truncate(normStr(r[c]) || "", 200))}</td>`);
          }
          return `<tr>${cells.join("")}</tr>`;
        }).join("");
        $(tableId).innerHTML = thead + `<tbody>${rowsHtml}</tbody>`;
      };

      renderRankTable("worstErrTable", idxWorst, "No rows.");
      const uncStatus = APP.train.uncertaintyStatus || "none";
      const uncEmpty = uncReady
        ? "No rows."
        : (uncStatus === "error")
          ? `Uncertainty failed: ${APP.train.uncertaintyError || "unknown error"}`
          : "Uncertainty is still computing (tree disagreement).";
      renderRankTable("highUncTable", idxUnc, uncEmpty);

      renderErrVsUncChart();
    }

    function renderErrVsUncChart() {
      const pl = APP.train.pipeline;
      if (!pl) return;

      const n = APP.train.testRowRefs.length;
      const uncReady = Array.isArray(APP.train.uncertainty) && APP.train.uncertainty.length === n;
      if (!uncReady) {
        $("errUncPill").className = "pill warn";
        $("errUncPill").textContent = "waiting for uncertainty‚Ä¶";
        APP.ui.charts.errUnc = destroyChart(APP.ui.charts.errUnc);
        return;
      }

      const maxPts = Math.min(2000, n);
      const rng = mulberry32(2025);
      const idx = Array.from({ length: n }, (_, i) => i);
      shuffleInPlace(idx, rng);
      const pick = idx.slice(0, maxPts);

      const pts = [];
      for (let j = 0; j < pick.length; j++) {
        const i = pick[j];
        const x0 = APP.train.absErr[i];
        const y0 = APP.train.uncertainty[i];
        if (!Number.isFinite(x0) || !Number.isFinite(y0)) continue;
        const x = (pl.task === "classification") ? (x0 + (rng() - 0.5) * 0.06) : x0;
        pts.push({ x, y: y0 });
      }

      $("errUncPill").className = "pill";
      $("errUncPill").textContent = `n=${pts.length}`;

      const ctx = $("errUncChart").getContext("2d");
      APP.ui.charts.errUnc = destroyChart(APP.ui.charts.errUnc);
      APP.ui.charts.errUnc = new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: [
            { label: "abs(error) vs uncertainty", data: pts, pointRadius: 2 },
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { title: { display: true, text: "abs(error)" }, ticks: { color: "rgba(234,240,255,0.75)" }, grid: { color: "rgba(234,240,255,0.08)" } },
            y: { title: { display: true, text: "uncertainty (tree disagreement)" }, ticks: { color: "rgba(234,240,255,0.75)" }, grid: { color: "rgba(234,240,255,0.08)" } },
          }
        }
      });
    }

    function buildPredictionsCsv() {
      const targetCol = APP.raw.targetCol;
      const cols = ["y_true", "y_pred", "err", "abs_err", "uncertainty"];
      if (APP.train.pipeline.task === "classification") cols.push("vote_frac_mode", "vote_margin", "vote_entropy");
      if (APP.train.pipeline.task === "regression") cols.push("tree_std");
      cols.push(...APP.raw.columns.filter(c => c !== targetCol));
      const inv = APP.train.pipeline.targetInvMapping;

      const lines = [];
      lines.push(cols.map(csvCell).join(","));

      for (let i = 0; i < APP.train.testRowRefs.length; i++) {
        const r = APP.train.testRowRefs[i];

        let yt = APP.train.yTest[i];
        let yp = APP.train.yPred[i];

        if (APP.train.pipeline.task === "classification") {
          yt = inv?.[yt] ?? yt;
          yp = APP.train.yPredLabel[i];
        }

        const row = [];
        row.push(String(yt));
        row.push(String(yp));
        row.push(String(APP.train.err?.[i] ?? ""));
        row.push(String(APP.train.absErr?.[i] ?? ""));
        row.push(String(Array.isArray(APP.train.uncertainty) ? (APP.train.uncertainty[i] ?? "") : ""));
        if (APP.train.pipeline.task === "classification") {
          const d = APP.train.uncertaintyDetails || {};
          row.push(String(Array.isArray(d.voteFracMode) ? (d.voteFracMode[i] ?? "") : ""));
          row.push(String(Array.isArray(d.voteMargin) ? (d.voteMargin[i] ?? "") : ""));
          row.push(String(Array.isArray(d.voteEntropy) ? (d.voteEntropy[i] ?? "") : ""));
        }
        if (APP.train.pipeline.task === "regression") {
          const d = APP.train.uncertaintyDetails || {};
          row.push(String(Array.isArray(d.treeStd) ? (d.treeStd[i] ?? "") : ""));
        }
        for (const c of APP.raw.columns.filter(c => c !== targetCol)) row.push(normStr(r[c]) || "");

        lines.push(row.map(csvCell).join(","));
      }

      return lines.join("\n");
    }

    // ----------------------------
    // Training
    // ----------------------------
    function trainingStatusHtml(task, completedUnits, totalUnits, startMs) {
      const elapsedMs = performance.now() - startMs;
      let etaText = "estimating‚Ä¶";
      if (completedUnits > 0 && totalUnits > 0) {
        const msPerUnit = elapsedMs / Math.max(1, completedUnits);
        const remainingMs = msPerUnit * Math.max(0, totalUnits - completedUnits);
        etaText = formatDuration(remainingMs);
      }

      const prog = (totalUnits > 0)
        ? `Tree <span class="mono">${completedUnits}</span>/<span class="mono">${totalUnits}</span>`
        : `Tree <span class="mono">${completedUnits}</span>`;

      return `<span class="spinner"></span> Training (${escapeHtml(task)})‚Ä¶ ` +
        `<span class="muted2">${prog} ¬∑ Elapsed <span class="mono">${formatDuration(elapsedMs)}</span> ¬∑ ETA <span class="mono">${etaText}</span></span>`;
    }

    function isFrac01(x) {
      return x > 0 && x <= 1;
    }

    function isFloatNotInt(x) {
      return Number(x) === x && x % 1 !== 0;
    }

    function rngFromSeed(seed) {
      if (seed === undefined) return MersenneTwister19937.autoSeed();
      if (Number.isInteger(seed)) return MersenneTwister19937.seed(seed);
      throw new RangeError(`Expected seed must be undefined or integer not ${seed}`);
    }

    function yieldToBrowserPaint() {
      return new Promise(resolve => {
        const raf = window.requestAnimationFrame || ((cb) => setTimeout(cb, 16));
        setTimeout(() => raf(() => resolve()), 0);
      });
    }

    function sampleWithBagging(X, y, seed, includeOob) {
      const engine = rngFromSeed(seed);
      const pickRow = integer(0, X.rows - 1);

      const bagIdx = new Array(X.rows);
      const ys = new Array(X.rows);
      const seen = includeOob ? new Uint8Array(X.rows) : null;
      let unseenCount = includeOob ? X.rows : 0;

      for (let i = 0; i < X.rows; i++) {
        const idx = pickRow(engine);
        bagIdx[i] = idx;
        ys[i] = y[idx];
        if (includeOob && seen[idx] === 0) {
          seen[idx] = 1;
          unseenCount--;
        }
      }

      const Xbag = new MatrixRowSelectionView(X, bagIdx);

      let Xoob = null;
      let ioob = [];
      if (includeOob) {
        const oobIdx = new Array(unseenCount);
        let p = unseenCount;
        for (let i = X.rows - 1; i >= 0 && p > 0; --i) {
          if (seen[i] === 0) oobIdx[--p] = i;
        }
        if (oobIdx.length) Xoob = new MatrixRowSelectionView(X, oobIdx);
        ioob = oobIdx;
      }

      return { X: Xbag, y: ys, Xoob, ioob, seed: engine.next() };
    }

    function selectRandomFeatures(X, n, replacement, seed) {
      if (X.columns < n) throw new RangeError("N should be less or equal to the number of columns of X");

      const engine = rngFromSeed(seed);
      const pickCol = integer(0, X.columns - 1);

      let usedIndex;
      if (replacement) {
        usedIndex = new Array(n);
        for (let i = 0; i < n; i++) {
          usedIndex[i] = pickCol(engine);
        }
      } else {
        const used = new Set();
        usedIndex = [];
        while (usedIndex.length < n) {
          const c = pickCol(engine);
          if (used.has(c)) continue;
          used.add(c);
          usedIndex.push(c);
        }
      }

      const Xsub = new MatrixColumnSelectionView(X, usedIndex);
      return { X: Xsub, usedIndex, seed: engine.next() };
    }

    function computeOobResults(oobEntries, y, selectionFn) {
      const all = Array.from({ length: y.length }, () => []);
      for (const entry of oobEntries) {
        if (!entry) continue;
        const idxs = entry.index || [];
        const preds = entry.predicted || [];
        for (let i = 0; i < idxs.length; i++) {
          all[idxs[i]].push(preds[i]);
        }
      }
      return all.map((preds, i) => {
        if (!preds.length) return null;
        return { true: y[i], all: preds, predicted: selectionFn(preds) };
      });
    }

    async function trainForestWithProgress(model, X, y, { onProgress, signal }) {
      let seed = model.seed;
      let Xm = Matrix.checkMatrix(X);
      let ym = y;

      model.maxFeatures = model.maxFeatures || Xm.columns;
      model.numberFeatures = Xm.columns;
      model.numberSamples = Xm.rows;

      if (isFrac01(model.maxFeatures)) model.n = Math.floor(Xm.columns * model.maxFeatures);
      else if (Number.isInteger(model.maxFeatures)) {
        if (model.maxFeatures > Xm.columns) throw new RangeError(`The maxFeatures parameter should be less than ${Xm.columns}`);
        model.n = model.maxFeatures;
      } else {
        throw new RangeError(`Cannot process the maxFeatures parameter ${model.maxFeatures}`);
      }

      if (model.maxSamples) {
        if (model.maxSamples < 0) throw new RangeError("Please choose a positive value for maxSamples");
        if (isFloatNotInt(model.maxSamples)) {
          if (model.maxSamples > 1) throw new RangeError("Please choose either a float value between 0 and 1 or a positive integer for maxSamples");
          model.numberSamples = Math.floor(Xm.rows * model.maxSamples);
        } else if (Number.isInteger(model.maxSamples)) {
          if (model.maxSamples > Xm.rows) throw new RangeError(`The maxSamples parameter should be less than ${Xm.rows}`);
          model.numberSamples = model.maxSamples;
        }
      }

      if (model.maxSamples && Xm.rows !== model.numberSamples) {
        const sub = new Matrix(model.numberSamples, Xm.columns);
        for (let i = 0; i < model.numberSamples; i++) sub.setRow(i, Xm.getRow(i));
        Xm = sub;
        ym = ym.slice(0, model.numberSamples);
      }

      const nEstimators = model.nEstimators;
      const TreeClass = model.isClassifier ? DecisionTreeClassifier : DecisionTreeRegression;

      model.estimators = new Array(nEstimators);
      model.indexes = new Array(nEstimators);

      const includeOob = Boolean(!model.noOOB && model.useSampleBagging);
      const oobEntries = includeOob ? new Array(nEstimators) : null;
      const yieldEvery = Math.max(1, Math.floor(nEstimators / 100));

      let trainedEstimators = 0;
      for (let t = 0; t < nEstimators; t++) {
        if (signal?.aborted) break;

        const bag = model.useSampleBagging
          ? sampleWithBagging(Xm, ym, seed, includeOob)
          : { X: Xm, y: ym, seed, Xoob: null, ioob: [] };
        seed = bag.seed;

        const feat = selectRandomFeatures(bag.X, model.n, model.replacement, seed);
        seed = feat.seed;

        model.indexes[t] = feat.usedIndex;
        model.estimators[t] = new TreeClass(model.treeOptions);
        model.estimators[t].train(feat.X, bag.y);

        if (includeOob && bag.Xoob && bag.ioob && bag.ioob.length) {
          const XoobSub = new MatrixColumnSelectionView(bag.Xoob, feat.usedIndex);
          oobEntries[t] = { index: bag.ioob, predicted: model.estimators[t].predict(XoobSub) };
        }

        trainedEstimators = t + 1;
        onProgress(trainedEstimators, nEstimators);

        if ((t + 1) < nEstimators && ((t + 1) % yieldEvery === 0)) {
          await new Promise(r => setTimeout(r, 0));
        }
      }

      if (trainedEstimators !== nEstimators) {
        model.estimators = model.estimators.slice(0, trainedEstimators);
        model.indexes = model.indexes.slice(0, trainedEstimators);
        model.nEstimators = trainedEstimators;
      }

      if (includeOob && oobEntries) {
        const used = oobEntries.slice(0, trainedEstimators);
        const oob = computeOobResults(used, ym, model.selection.bind(model));
        const oobPred = oob.map(x => (x && x.predicted !== undefined) ? x.predicted : null);
        const covered = oobPred.reduce((a, v) => a + (v === null ? 0 : 1), 0);
        const complete = oob.length && oob.every(x => x && x.predicted !== null && x.predicted !== undefined);
        if (complete) model.oobResults = oob;
        return { trainedEstimators, stoppedEarly: trainedEstimators !== nEstimators, oobPred, oobCovered: covered };
      }

      return { trainedEstimators, stoppedEarly: trainedEstimators !== nEstimators, oobPred: null, oobCovered: 0 };
    }

    async function trainModel() {
      const abortController = new AbortController();
      APP.ui.training.abortController = abortController;
      APP.ui.training.stopRequested = false;
      setTrainingUi(true);

      APP.ui.training.runSeq = (APP.ui.training.runSeq || 0) + 1;
      const runSeq = APP.ui.training.runSeq;
      APP.ui.shiftAutoExpandedRunSeq = 0;

      try { APP.ui.training.diagAbortController?.abort(); } catch {}
      APP.ui.training.diagAbortController = new AbortController();
      const diagSignal = APP.ui.training.diagAbortController.signal;

      if (APP.train.runSummary) {
        APP.ui.prevRunSummary = { ...APP.train.runSummary };
      }

      APP.ui.training.startMs = performance.now();
      $("trainStatus").innerHTML = `<span class="spinner"></span> Preparing data‚Ä¶`;

      await new Promise(r => setTimeout(r, 0));

      const testFrac = Math.min(0.5, Math.max(0.05, parseNum($("testFrac").value) || 0.1));
      APP.setup.testFrac = testFrac;

      const seed = Math.floor(parseNum($("seed").value) || 42);
      const replacement = ($("replacement").value === "true");
      const nEstimators = Math.max(10, Math.floor(parseNum($("nEstimators").value) || 100));

      const splitMode = effectiveSplitMode();
      const splitDateCol = (splitMode === "time") ? APP.setup.splitDateCol : null;

      let built;
      try {
        built = buildDataset(seed, testFrac, splitMode, splitDateCol);
      } catch (e) {
        $("trainStatus").innerHTML = `<span class="pill bad">Failed</span> <span class="mono">${escapeHtml(e?.message || String(e))}</span>`;
        APP.ui.training.abortController = null;
        APP.ui.training.stopRequested = false;
        setTrainingUi(false);
        return;
      }

      const { Xtrain, ytrain, Xtest, ytest, testRowRefs, trainRowRefs, featureNames, baseForDerived, pipeline, task, dropped } = built;

      if (!pipeline || !Xtrain.length || !Xtest.length) {
        const hint = (!pipeline || !Xtrain.length)
          ? "Check target parsing/transform choice, and ensure enough usable rows exist."
          : "Test split ended up empty after filtering (e.g., unseen labels). Try a different split or larger sample.";
        $("trainStatus").innerHTML = `<span class="pill bad">No usable rows</span> <span class="muted2">${escapeHtml(hint)}</span>`;
        APP.ui.training.abortController = null;
        APP.ui.training.stopRequested = false;
        setTrainingUi(false);
        return;
      }

      const maxFeaturesParsed = parseMaxFeatures($("maxFeatures").value, featureNames.length);
      const maxDepth = parseOptionalPositiveInt($("maxDepth")?.value);
      const minNumSamples = parseOptionalPositiveInt($("minNumSamples")?.value);
      const treeOptions = {};
      if (maxDepth !== null) treeOptions.maxDepth = maxDepth;
      if (minNumSamples !== null) treeOptions.minNumSamples = minNumSamples;
      const rfOptions = {
        seed,
        maxFeatures: maxFeaturesParsed,
        replacement,              // feature sampling replacement (usually false)
        nEstimators,
        useSampleBagging: true,   // bootstrap rows (actual ‚Äúbagging‚Äù)
        treeOptions,
      };

      APP.ui.training.totalUnits = nEstimators;
      APP.ui.training.completedUnits = 0;
      $("trainStatus").innerHTML = trainingStatusHtml(task, 0, nEstimators, APP.ui.training.startMs);
      await new Promise(r => setTimeout(r, 0));

      let model;
      let trainInfo;
      try {
        model = (task === "regression") ? new RandomForestRegression(rfOptions) : new RandomForestClassifier(rfOptions);
        trainInfo = await trainForestWithProgress(model, Xtrain, ytrain, {
          onProgress: (completedUnits, totalUnits) => {
            APP.ui.training.completedUnits = completedUnits;
            APP.ui.training.totalUnits = totalUnits;
            $("trainStatus").innerHTML = trainingStatusHtml(task, completedUnits, totalUnits, APP.ui.training.startMs);
          },
          signal: abortController.signal,
        });
      } catch (e) {
        if (isAbortError(e) || APP.ui.training.stopRequested) {
          $("trainStatus").innerHTML = `<span class="pill warn">Stopped</span> <span class="muted2">Training aborted.</span>`;
        } else {
          $("trainStatus").innerHTML = `<span class="pill bad">Train failed</span> <span class="mono">${escapeHtml(e?.message || String(e))}</span>`;
        }
        APP.ui.training.abortController = null;
        APP.ui.training.stopRequested = false;
        setTrainingUi(false);
        return;
      }

      if (!trainInfo?.trainedEstimators) {
        $("trainStatus").innerHTML = `<span class="pill warn">Stopped</span> <span class="muted2">No trees were trained.</span>`;
        APP.ui.training.abortController = null;
        APP.ui.training.stopRequested = false;
        setTrainingUi(false);
        return;
      }

      if (trainInfo?.stoppedEarly) {
        $("trainStatus").innerHTML =
          `<span class="spinner"></span> Training stopped early ` +
          `<span class="muted2">(trees <span class="mono">${trainInfo.trainedEstimators}</span>/<span class="mono">${nEstimators}</span>). Scoring‚Ä¶</span>`;
        await new Promise(r => setTimeout(r, 0));
      }

      $("trainStatus").innerHTML = `<span class="spinner"></span> Scoring test split‚Ä¶`;
      await new Promise(r => setTimeout(r, 0));

      let ypred;
      try {
        ypred = model.predict(Xtest);
      } catch (e) {
        if (isAbortError(e) || APP.ui.training.stopRequested) {
          $("trainStatus").innerHTML = `<span class="pill warn">Stopped</span> <span class="muted2">Training aborted.</span>`;
        } else {
          $("trainStatus").innerHTML = `<span class="pill bad">Predict failed</span> <span class="mono">${escapeHtml(e?.message || String(e))}</span>`;
        }
        APP.ui.training.abortController = null;
        APP.ui.training.stopRequested = false;
        setTrainingUi(false);
        return;
      }

      let oobPred = trainInfo?.oobPred || null;
      if (!oobPred) {
        try { oobPred = model.predictOOB(); } catch {}
      }

      let fi = null;
      try { fi = model.featureImportance(); } catch { fi = null; }

      const fiDerived = (fi && fi.length === featureNames.length)
        ? featureNames.map((name, i) => ({ name, imp: Number.isFinite(fi[i]) ? fi[i] : 0 }))
            .sort((a,b)=>b.imp-a.imp)
        : [];

      const fiBase = (fi && fi.length === featureNames.length)
        ? aggregateFI(fi, featureNames, baseForDerived)
        : [];

      const transform = pipeline.targetTransform;
      let ytestRaw = ytest.slice();
      let ypredRaw = ypred.slice();

      if (pipeline.task === "regression" && transform === "log1p") {
        ytestRaw = ytest.map(v => Math.expm1(v));
        ypredRaw = ypred.map(v => Math.expm1(v));
      }

      const invTarget = buildInverseMapping(pipeline.target.mapping);

      APP.train.rfOptions = rfOptions;
      APP.train.model = model;
      APP.train.pipeline = { ...pipeline, targetInvMapping: invTarget };
      APP.ui.maxUnlockedStep = Math.max(APP.ui.maxUnlockedStep || 0, 3);
      renderStepper();
      APP.train.featureNames = featureNames;
      APP.train.baseForDerived = baseForDerived;
      APP.train.derivedTypeByFeature = buildDerivedTypeByFeature(featureNames, baseForDerived);
      APP.train.split = {
        trainIdx: Array.from({ length: Xtrain.length }, (_, i) => i),
        testIdx: Array.from({ length: Xtest.length }, (_, i) => i)
      };
      APP.train.yTrain = ytrain;
      APP.train.yTest = ytestRaw;
      APP.train.yPred = ypredRaw;
      APP.train.err = new Array(ytestRaw.length);
      APP.train.absErr = new Array(ytestRaw.length);
      APP.train.oobPred = oobPred;
      APP.train.testRowRefs = testRowRefs;
      APP.train.fiDerived = fiDerived;
      APP.train.fiBase = fiBase;
      APP.train.dropped = dropped;
      APP.train.shift = { status: "running" };
      APP.train.uncertainty = null;
      APP.train.uncertaintyDetails = null;
      APP.train.uncertaintyStatus = "running";
      APP.train.uncertaintyError = "";

      if (pipeline.task === "classification") {
        const inv = invTarget || {};
        APP.train.yPredLabel = ypred.map(v => String(inv[v] ?? v));
        APP.train.yTestLabel = ytest.map(v => String(inv[v] ?? v));
      } else {
        APP.train.yPredLabel = ypredRaw.map(v => String(v));
        APP.train.yTestLabel = ytestRaw.map(v => String(v));
      }

      for (let i = 0; i < ytestRaw.length; i++) {
        if (pipeline.task === "regression") {
          const e = Number(ypredRaw[i]) - Number(ytestRaw[i]);
          APP.train.err[i] = e;
          APP.train.absErr[i] = Math.abs(e);
        } else {
          const e = (Number(ypred[i]) === Number(ytest[i])) ? 0 : 1;
          APP.train.err[i] = e;
          APP.train.absErr[i] = e;
        }
      }

      // Run summary (test + OOB, for compare + pruning loop)
      const testSummary = (pipeline.task === "regression")
        ? (() => {
          const rm = rmse(ytestRaw, ypredRaw);
          const ma = mae(ytestRaw, ypredRaw);
          const r = r2(ytestRaw, ypredRaw);
          const rl = rmsle(ytestRaw, ypredRaw);
          return { primaryLabel: "Test RMSE", primary: rm, sub: `MAE=${formatNum(ma,6)} ¬∑ R¬≤=${formatNum(r,6)} ¬∑ RMSLE=${rl===null?"n/a":formatNum(rl,6)}` };
        })()
        : (() => {
          const yT = ytest.map(v => Number(v));
          const yP = ypred.map(v => Number(v));
          const acc = accuracy(yT, yP);
          const f1 = f1Macro(yT, yP, pipeline.target.numClasses || 2);
          return { primaryLabel: "Test Accuracy", primary: acc, sub: `Macro-F1=${formatNum(f1,6)} ¬∑ Classes=${pipeline.target.numClasses}` };
        })();

      let oobSummary = null;
      if (Array.isArray(oobPred) && oobPred.length === ytrain.length) {
        if (pipeline.task === "regression") {
          const ytRaw = (pipeline.targetTransform === "log1p") ? ytrain.map(v => Math.expm1(v)) : ytrain.slice();
          const ypRaw = (pipeline.targetTransform === "log1p")
            ? oobPred.map(v => (v === null || v === undefined) ? null : Math.expm1(v))
            : oobPred.map(v => (v === null || v === undefined) ? null : Number(v));
          const f = filterPaired(ytRaw, ypRaw);
          const cov = f.yTrue.length / Math.max(1, ytrain.length);
          const oobRm = f.yTrue.length ? rmse(f.yTrue, f.yPred) : null;
          oobSummary = { label: "OOB RMSE", value: oobRm, coverage: cov, sub: `OOB cov=${Math.round(cov * 100)}%` };
        } else {
          const f = filterPaired(ytrain.map(v => Number(v)), oobPred.map(v => (v === null || v === undefined) ? null : Number(v)));
          const cov = f.yTrue.length / Math.max(1, ytrain.length);
          const oobAcc = f.yTrue.length ? accuracy(f.yTrue, f.yPred) : null;
          oobSummary = { label: "OOB Accuracy", value: oobAcc, coverage: cov, sub: `OOB cov=${Math.round(cov * 100)}%` };
        }
      }

      APP.train.runSummary = {
        runId: Date.now(),
        task: pipeline.task,
        test: testSummary,
        oob: oobSummary,
        includedCols: currentIncludedFeatureCols().length,
        excludedCols: APP.setup.excluded?.size || 0,
        pruneReason: APP.ui.pruneJustApplied ? (APP.ui.pruneUndoReason || "") : "",
      };
      APP.ui.pruneJustApplied = false;

      // Render results ASAP (test metrics + plots). Diagnostics fill in asynchronously below.
      renderResults();
      gotoStep(3);

      $("trainStatus").innerHTML = `<span class="pill good">Done</span> <span class="muted2">Model trained locally.</span>`;
      showToast("Training complete", "good");
      APP.ui.training.abortController = null;
      APP.ui.training.stopRequested = false;
      setTrainingUi(false);

      // Background: shift diagnostic
      (async () => {
        try {
          await yieldToBrowserPaint();
          const shift = await computeShiftDiagnostics({
            trainRows: trainRowRefs,
            testRows: testRowRefs,
            pipeline,
            featureNames,
            baseForDerived,
            seed,
            signal: diagSignal,
          });
          if (runSeq !== APP.ui.training.runSeq) return;
          APP.train.shift = shift || null;
          renderShiftSection();
        } catch {
          if (runSeq !== APP.ui.training.runSeq) return;
          APP.train.shift = null;
          renderShiftSection();
        }
      })();

      // Background: uncertainty via tree disagreement (predictionValues)
      (async () => {
        try {
          await yieldToBrowserPaint();
          const out = await computeTreeDisagreementUncertainty({
            model,
            X: Xtest,
            pipeline,
            ensemblePred: (pipeline.task === "classification") ? ypred : null,
            signal: diagSignal,
          });
          if (runSeq !== APP.ui.training.runSeq) return;
          APP.train.uncertainty = out.uncertainty || null;
          APP.train.uncertaintyDetails = out.details || null;
          APP.train.uncertaintyStatus = "ready";
          APP.train.uncertaintyError = "";
        } catch (e) {
          if (runSeq !== APP.ui.training.runSeq) return;
          APP.train.uncertainty = null;
          APP.train.uncertaintyDetails = null;
          APP.train.uncertaintyStatus = "error";
          APP.train.uncertaintyError = e?.message || String(e);
        }
        renderPredInsights();
        renderPredTable();
      })();
    }

    // ----------------------------
    // Results rendering
    // ----------------------------
    function renderShiftSection() {
      const shift = APP.train.shift;
      const isRunning = Boolean(shift && shift.status === "running");
      const shiftScore = shift?.oobBalAcc ?? shift?.oobAcc ?? null;

      if (isRunning) {
        $("shiftPill").className = "pill";
        $("shiftPill").textContent = "Shift: running‚Ä¶";
        $("shiftSummary").textContent = "Training an is_valid model in the background (predict train vs validation).";
        return;
      }

      if (!shift || shiftScore === null) {
        $("shiftPill").className = "pill";
        $("shiftPill").textContent = "Shift: n/a";
        $("shiftSummary").textContent = "Shift diagnostic unavailable (not enough rows, or OOB not available).";
        APP.ui.charts.shift = destroyChart(APP.ui.charts.shift);
        try {
          const c = $("shiftFiChart");
          const ctx = c.getContext("2d");
          ctx.clearRect(0, 0, c.width, c.height);
        } catch {}
        return;
      }

      const details = $("shiftDetails");
      if (details && shiftScore > 0.6 && APP.ui.shiftAutoExpandedRunSeq !== APP.ui.training.runSeq) {
        details.open = true;
        APP.ui.shiftAutoExpandedRunSeq = APP.ui.training.runSeq;
      }

      const cov = shift.nTotal ? (shift.oobCovered / shift.nTotal) : 0;
      const covTxt = `${Math.round(cov * 100)}%`;
      const balTxt = formatNum(shiftScore, 6);
      const accTxt = (shift.oobAcc === null) ? "n/a" : formatNum(shift.oobAcc, 6);
      const f1Txt = (shift.oobF1 === null) ? "n/a" : formatNum(shift.oobF1, 6);
      const baseline = shift.nTotal ? (Math.max(shift.nTrainUsed || 0, shift.nTestUsed || 0) / shift.nTotal) : null;
      const baselineTxt = (baseline === null) ? "n/a" : formatNum(baseline, 6);
      const severity = (shiftScore >= 0.90) ? "bad" : (shiftScore >= 0.75) ? "warn" : "good";

      $("shiftPill").className = `pill ${severity}`.trim();
      $("shiftPill").textContent = `Shift OOB bal-acc=${balTxt}`;
      $("shiftSummary").innerHTML =
        `<div style="margin-bottom:6px;">This trains a second random forest where the target is <span class="mono">is_valid</span>: <span class="mono">0</span>=train, <span class="mono">1</span>=validation.</div>` +
        `<div style="margin-bottom:6px;">If it can easily predict which split a row came from, your validation set is in a different ‚Äúdomain‚Äù (time shift, IDs, leakage, changing missingness).</div>` +
        `<div style="margin-bottom:6px;">Interpretation: <span class="mono">~0.50</span> is good (hard to tell); <span class="mono">‚â•0.75</span> suggests strong shift; <span class="mono">‚â•0.90</span> is severe.</div>` +
        `<div style="margin-bottom:6px;">Score: OOB bal-acc <span class="mono">${balTxt}</span> ¬∑ raw acc <span class="mono">${accTxt}</span> ¬∑ baseline <span class="mono">${baselineTxt}</span> ¬∑ F1 <span class="mono">${f1Txt}</span> ¬∑ OOB coverage <span class="mono">${covTxt}</span>.</div>` +
        `<div class="muted2" style="margin-bottom:6px;">Rows used: train=<span class="mono">${shift.nTrainUsed}</span>, valid=<span class="mono">${shift.nTestUsed}</span> (balanced on purpose).</div>` +
        `<div>Use ‚ÄúTop shift drivers‚Äù to spot culprits (often IDs, timestamps/elapsed, or proxies for the target). Try excluding them, changing the cutoff, or using only recent data.</div>`;

      renderShiftFIChart(shift.fiBase || []);
      updatePruneMiniUi();
    }

    function renderResults() {
      const pl = APP.train.pipeline;
      const task = pl.task;

      const splitMode = effectiveSplitMode();
      const splitText = splitMode === "time"
        ? `time-based (${APP.setup.splitDateCol})`
        : "random";

      $("setupSummary").textContent =
        `Target=${pl.targetCol} ¬∑ Task=${task} ¬∑ Split=${splitText} ¬∑ Test=${Math.round(APP.setup.testFrac*100)}%`;

      $("featureSummary").textContent =
        `Rows: train=${APP.train.split.trainIdx.length}, test=${APP.train.split.testIdx.length} ¬∑ Features=${APP.train.featureNames.length} ¬∑ Transform=${pl.targetTransform}`;

      $("resultsCallouts").innerHTML = "";

      const addCallout = (cls, title, body) => {
        const el = document.createElement("div");
        el.className = `callout ${cls || ""}`.trim();
        el.innerHTML = `<div style="font-weight:650;margin-bottom:6px;">${escapeHtml(title)}</div>
                        <div class="muted2">${body}</div>`;
        $("resultsCallouts").appendChild(el);
      };

      if (APP.train.dropped?.unusableTargetRows) {
        addCallout("warn", "Some rows were dropped (target not usable)",
          `Dropped <span class="mono">${APP.train.dropped.unusableTargetRows}</span> rows due to missing/invalid target values (or incompatible log1p).`
        );
      }
      if (APP.train.dropped?.unseenTestLabels) {
        addCallout("warn", "Some test rows were dropped (unseen labels)",
          `Dropped <span class="mono">${APP.train.dropped.unseenTestLabels}</span> test rows because their label never appeared in the training split (train-only label encoding).`
        );
      }

      const cur = APP.train.runSummary;
      if (cur?.pruneReason) {
        addCallout("", "Prune applied", escapeHtml(cur.pruneReason));
      }

      const prev = APP.ui.prevRunSummary;
      if (prev && prev.runId && cur && cur.runId && prev.runId !== cur.runId && prev.task === cur.task) {
        const betterIsLower = (cur.task === "regression");
        const a = Number(prev.test?.primary);
        const b = Number(cur.test?.primary);
        const delta = (Number.isFinite(a) && Number.isFinite(b)) ? (b - a) : null;
        const improved = (delta !== null)
          ? (betterIsLower ? (delta < 0) : (delta > 0))
          : null;

        const cls = (improved === null) ? "" : (improved ? "good" : "warn");
        const deltaTxt = (delta === null) ? "n/a" : `${delta >= 0 ? "+" : ""}${formatNum(delta, 6)}`;
        const prevTxt = Number.isFinite(a) ? formatNum(a, 6) : "n/a";
        const curTxt = Number.isFinite(b) ? formatNum(b, 6) : "n/a";

        const oA = Number(prev.oob?.value);
        const oB = Number(cur.oob?.value);
        const oDelta = (Number.isFinite(oA) && Number.isFinite(oB)) ? (oB - oA) : null;
        const oDeltaTxt = (oDelta === null) ? "n/a" : `${oDelta >= 0 ? "+" : ""}${formatNum(oDelta, 6)}`;

        addCallout(cls, "Compare to previous run",
          `${escapeHtml(cur.test?.primaryLabel || "Test metric")}: <span class="mono">${escapeHtml(curTxt)}</span> (prev <span class="mono">${escapeHtml(prevTxt)}</span>, Œî <span class="mono">${escapeHtml(deltaTxt)}</span>)` +
          (prev.oob?.label && cur.oob?.label
            ? `<div style="margin-top:6px;">${escapeHtml(cur.oob.label)}: <span class="mono">${escapeHtml(Number.isFinite(oB) ? formatNum(oB, 6) : "n/a")}</span> (prev <span class="mono">${escapeHtml(Number.isFinite(oA) ? formatNum(oA, 6) : "n/a")}</span>, Œî <span class="mono">${escapeHtml(oDeltaTxt)}</span>)</div>`
            : "") +
          `<div style="margin-top:6px;">Columns: included <span class="mono">${cur.includedCols}</span> (prev <span class="mono">${prev.includedCols}</span>) ¬∑ excluded <span class="mono">${cur.excludedCols}</span> (prev <span class="mono">${prev.excludedCols}</span>)</div>`
        );
      }

      if (task === "regression") {
        const yTrue = APP.train.yTest;
        const yPred = APP.train.yPred;

        const rm = rmse(yTrue, yPred);
        const ma = mae(yTrue, yPred);
        const r = r2(yTrue, yPred);
        const rl = rmsle(yTrue, yPred);

        $("primaryMetricLabel").textContent = "Test RMSE";
        $("primaryMetricValue").textContent = formatNum(rm, 6);
        $("primaryMetricSub").textContent = `MAE=${formatNum(ma,6)} ¬∑ R¬≤=${formatNum(r,6)} ¬∑ RMSLE=${rl===null?"n/a":formatNum(rl,6)}`;

        $("secondaryChartTitle").textContent = "Predicted vs true (scatter)";
        $("secondaryChartPill").textContent = `n=${APP.train.yTest.length}`;
        $("secondaryChartHint").textContent = "Ideally points cluster around the diagonal. Outliers can indicate missingness, leakage, or rare categories.";
        renderRegressionScatter(APP.train.yTest, APP.train.yPred);

      } else {
        const yTrue = APP.train.yTest.map(v => Number(v));
        const yPred = APP.train.yPred.map(v => Number(v));

        const acc = accuracy(yTrue, yPred);
        const f1 = f1Macro(yTrue, yPred, pl.target.numClasses || 2);

        $("primaryMetricLabel").textContent = "Test Accuracy";
        $("primaryMetricValue").textContent = formatNum(acc, 6);
        $("primaryMetricSub").textContent = `Macro-F1=${formatNum(f1,6)} ¬∑ Classes=${pl.target.numClasses}`;

        $("secondaryChartTitle").textContent = "Confusion matrix (top classes)";
        $("secondaryChartPill").textContent = `classes=${pl.target.numClasses}`;
        $("secondaryChartHint").textContent = "Rows are true labels, columns are predicted. Cell shading is row-normalized; diagonal highlighted. For many classes, we show only the most frequent.";
        renderConfusionMatrix(yTrue, yPred, pl.targetInvMapping, 15);
      }

      renderShiftSection();

      const mode = $("importanceMode").value;
      if (mode === "derived") renderFIChart(APP.train.fiDerived, "importance", "derived");
      else renderFIChart(APP.train.fiBase, "importance", "base");

      APP.ui.predPage = 0;
      $("predFilter").value = "";
      if ($("predFullDetails")) $("predFullDetails").open = false;
      if ($("predInsightsDetails")) $("predInsightsDetails").open = false;
      updateUncertaintyPills();
      renderPredInsights();
      renderPredTable();
      updatePruneMiniUi();

      updateExportUI();
    }

    // ----------------------------
    // Export
    // ----------------------------
    function buildArtifact() {
      const model = APP.train.model;
      const pipeline = APP.train.pipeline;
      if (!model || !pipeline) return null;

      return {
        schemaVersion: pipeline.schemaVersion,
        createdAt: pipeline.createdAt,
        fileName: pipeline.fileName,
        originalColumns: pipeline.originalColumns,
        includedColumns: pipeline.includedColumns,
        selectedTypes: Object.fromEntries(Object.entries(APP.raw.colMeta).map(([k, v]) => [k, v.inferredType])),
        typing: {
          maxCard: APP.setup.maxCard,
          excludeCols: APP.setup.excludeCols,
          forceDate: APP.setup.forceDate,
          forceCat: APP.setup.forceCat,
          forceCont: APP.setup.forceCont,
        },
        targetCol: pipeline.targetCol,
        task: pipeline.task,
        targetTransform: pipeline.targetTransform,
        derivedFeatureNames: pipeline.derivedFeatureNames,
        derivedFeatureBase: pipeline.derivedFeatureBase,
        preprocess: pipeline.preprocess,
        target: {
          col: pipeline.target.col,
          mapping: pipeline.target.mapping,
          numClasses: pipeline.target.numClasses
        },
        rfOptions: APP.train.rfOptions,
        model: model.toJSON(),
        library: pipeline.library,
        fittedOn: pipeline.fittedOn
      };
    }

    function buildSampleCode(artifact) {
      return `/**
 * rf_artifact.json contains:
 * - preprocessing pipeline (label encoders, medians, date expansion)
 * - a serialized ml-random-forest model (toJSON())
 *
 * Browser example uses ESM CDN import via esm.sh
 * Node example uses 'ml-random-forest' from npm.
 */

import { RandomForestRegression, RandomForestClassifier } from "https://esm.sh/ml-random-forest@2.1.0";

function normStr(v){ return (v===null||v===undefined) ? "" : String(v).trim(); }
function parseNum(v){ const s=normStr(v); if(!s) return NaN; const x=Number(s); return Number.isFinite(x)?x:NaN; }

function looksLikeDateString(s){
  const t=s.trim(); if(!t) return false;
  if(!(/[\\/\\-T:]/.test(t))) return false;
  const p1=/^\\d{4}[-\\/]\\d{1,2}[-\\/]\\d{1,2}(\\b|T)/;
  const p2=/^\\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4}(\\b|T)/;
  const p3=/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;
  return p1.test(t)||p2.test(t)||p3.test(t);
}
function parseDate(v){
  const s=normStr(v); if(!s) return null;
  if(!looksLikeDateString(s)) return null;
  const d=new Date(s); if(Number.isNaN(d.getTime())) return null;
  return d;
}
function dateParts(d){
  function isoWeekNumber(d){
    const dt=new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    const dayNum=dt.getUTCDay()||7;
    dt.setUTCDate(dt.getUTCDate()+4-dayNum);
    const yearStart=new Date(Date.UTC(dt.getUTCFullYear(),0,1));
    return Math.ceil((((dt-yearStart)/86400000)+1)/7);
  }

  const year=d.getFullYear(), month=d.getMonth()+1, week=isoWeekNumber(d), day=d.getDate(), dow=d.getDay();
  const start=new Date(d.getFullYear(),0,1);
  const dayOfYear=Math.floor((d-start)/86400000)+1;

  const isMonthStart=(day===1);
  const isMonthEnd=(new Date(d.getFullYear(), d.getMonth()+1, 0).getDate()===day);

  const qStart=new Set([1,4,7,10]), qEnd=new Set([3,6,9,12]);
  const isQuarterStart=qStart.has(month)&&isMonthStart;
  const isQuarterEnd=qEnd.has(month)&&isMonthEnd;

  const isYearStart=(month===1&&day===1);
  const isYearEnd=(month===12&&day===31);

  return {
    year,month,week,day,dayofweek:dow,dayofyear:dayOfYear,
    is_month_end:isMonthEnd?1:0, is_month_start:isMonthStart?1:0,
    is_quarter_end:isQuarterEnd?1:0, is_quarter_start:isQuarterStart?1:0,
    is_year_end:isYearEnd?1:0, is_year_start:isYearStart?1:0,
    elapsed:d.getTime()
  };
}

function transformRow(row, artifact){
  const contCols=artifact.preprocess.continuous.cols;
  const catCols=artifact.preprocess.categorical.cols;
  const dateCols=artifact.preprocess.date.cols;

  const feats=[];

  for(const c of contCols){
    const x=parseNum(row[c]);
    const miss=!Number.isFinite(x);
    feats.push(miss ? artifact.preprocess.continuous.median[c] : x);
    feats.push(miss ? 1 : 0);
  }

  for(const c of catCols){
    const s=normStr(row[c]) || artifact.preprocess.categorical.missingToken;
    const m=artifact.preprocess.categorical.mapping[c];
    feats.push((m[s]===undefined) ? artifact.preprocess.categorical.unknownId : m[s]);
  }

  for(const c of dateCols){
    const d=parseDate(row[c]);
    const miss=!d;
    const dt=miss ? new Date(artifact.preprocess.date.medianElapsed[c]) : d;
    const p=dateParts(dt);

    feats.push(p.year); feats.push(p.month); feats.push(p.week); feats.push(p.day);
    feats.push(p.dayofweek); feats.push(p.dayofyear);
    feats.push(p.is_month_end); feats.push(p.is_month_start);
    feats.push(p.is_quarter_end); feats.push(p.is_quarter_start);
    feats.push(p.is_year_end); feats.push(p.is_year_start);
    feats.push(p.elapsed);
    feats.push(miss ? 1 : 0);
  }

  return feats;
}

function loadModel(artifact){
  return (artifact.task==="regression")
    ? RandomForestRegression.load(artifact.model)
    : RandomForestClassifier.load(artifact.model);
}

function invertTargetIfNeeded(yPred, artifact){
  if(artifact.task!=="regression") return yPred;
  if(artifact.targetTransform==="log1p") return Math.expm1(yPred);
  return yPred;
}

// Example:
// const artifact = await (await fetch("./rf_artifact.json")).json();
// const model = loadModel(artifact);
// const x = transformRow(rowObj, artifact);
// let yPred = model.predict([x])[0];
// yPred = invertTargetIfNeeded(yPred, artifact);
// console.log("prediction:", yPred);
`;
    }

    async function updateExportUI() {
      const artifact = buildArtifact();
      if (!artifact) {
        $("artifactPill").className = "pill";
        $("artifactPill").textContent = "Artifact: not ready";
        $("artifactDetailPill").textContent = "Train a model first";
        $("downloadZipBtn").disabled = true;
        $("sampleCode").textContent = "";
        return;
      }

      $("artifactPill").className = "pill good";
      $("artifactPill").textContent = "Artifact: ready";
      $("artifactDetailPill").textContent = `task=${artifact.task} ¬∑ features=${artifact.derivedFeatureNames.length}`;
      $("downloadZipBtn").disabled = false;
      $("sampleCode").textContent = buildSampleCode(artifact);
      APP.ui.maxUnlockedStep = Math.max(APP.ui.maxUnlockedStep || 0, 4);
      renderStepper();
    }

    // ----------------------------
    // App wiring
    // ----------------------------
    function syncButtons() {
      $("continueToSetupBtn").disabled = !(APP.raw.rows.length && APP.raw.columns.length);
      $("continueToTrainBtn").disabled = !APP.raw.targetCol;
      setTrainingUi(APP.ui.training.isTraining);
      updateExportUI();
      renderTrainChips();
    }

	    function hardReset() {
      try { APP.ui.training.abortController?.abort(); } catch {}
      try { APP.ui.training.diagAbortController?.abort(); } catch {}
      APP.ui.training.abortController = null;
      APP.ui.training.diagAbortController = null;
      APP.ui.training.isTraining = false;
      APP.ui.training.stopRequested = false;
      APP.ui.training.runSeq = 0;
      APP.ui.shiftAutoExpandedRunSeq = 0;

      APP.ui.parseSeq = (APP.ui.parseSeq || 0) + 1;
      APP.step = 0;
      APP.raw = { fileName: null, rows: [], columns: [], colMeta: {}, targetCol: null };
      APP.setup = {
        splitDateCol: null,
        splitMethod: "cutoff",
        cutoffDate: "",
        splitStrategy: "random",
        testFrac: 0.1,
        taskMode: "auto",
        targetTransform: "none",
        maxRows: 50000,
        maxCard: 50,
        forceDate: "",
        forceCat: "",
        forceCont: "",
        excludeCols: "",
        excluded: new Set(),
        forcedTypes: {
          date: new Set(),
          categorical: new Set(),
          continuous: new Set(),
        },
        multiClass: {
          topN: {
            enabled: false,
            keep: 5,
            rareLabel: "RARE",
          },
          derivedTarget: {
            enabled: false,
            sourceCol: null,
            derivedCol: "",
            expr: "",
            lastStatus: "",
            lastError: "",
          },
        },
      };
      syncHiddenTypingLists();
      APP.train = {
        rfOptions: null,
        model: null,
        pipeline: null,
        featureNames: [],
        baseForDerived: [],
        derivedTypeByFeature: null,
        split: { trainIdx: [], testIdx: [] },
        yTrain: [],
        yTest: [],
        yPred: [],
        yPredLabel: [],
        err: [],
        absErr: [],
        uncertainty: null,
        uncertaintyDetails: null,
        uncertaintyStatus: "none",
        uncertaintyError: "",
        runSummary: null,
        oobPred: null,
        testRowRefs: [],
        fiDerived: [],
        fiBase: [],
        shift: null,
        dropped: { unusableTargetRows: 0, unseenTestLabels: 0, sampledRows: 0, usableRows: 0 }
      };
      APP.ui.predPage = 0;
      APP.ui.predFilter = "";
      APP.ui.previewFilter = "";
      APP.ui.prevRunSummary = null;
      APP.ui.pruneUndoExcluded = null;
      APP.ui.pruneUndoReason = "";
      APP.ui.pruneJustApplied = false;
      APP.ui.maxUnlockedStep = 0;

      APP.ui.charts.fi = destroyChart(APP.ui.charts.fi);
      APP.ui.charts.secondary = destroyChart(APP.ui.charts.secondary);
      APP.ui.charts.shift = destroyChart(APP.ui.charts.shift);
      APP.ui.charts.errUnc = destroyChart(APP.ui.charts.errUnc);

      $("trainStatus").innerHTML = "";
	      setTrainingUi(false);

      hide($("uploadSummary"));
      show($("dropZone"));
      $("uploadStatus").innerHTML = "";
      $("previewTable").innerHTML = "";
      if ($("targetSearch")) $("targetSearch").value = "";
      $("predTable").innerHTML = "";
      $("worstErrTable").innerHTML = "";
      $("highUncTable").innerHTML = "";
      $("resultsCallouts").innerHTML = "";
      $("uncertaintyPill").textContent = "Uncertainty: ‚Äî";
      $("uncertaintyPill").className = "pill";
      $("errUncPill").textContent = "‚Äî";
      $("errUncPill").className = "pill";
      if ($("predInsightsDetails")) $("predInsightsDetails").open = false;
      $("pruneUndoBtn").disabled = true;
      $("pruneImpBtn").disabled = true;
      $("pruneShiftTopBtn").disabled = true;
      $("pruneMiniHint").textContent = "‚Äî";
      hide($("pruneImpRow"));
      $("shiftPill").textContent = "‚Äî";
      $("shiftPill").className = "pill";
      $("shiftSummary").textContent = "‚Äî";
      if ($("shiftDetails")) $("shiftDetails").open = false;

      $("testFrac").value = "0.1";
      $("cutoffDate").value = "";
      $("seed").value = "42";
      $("maxRows").value = "50000";
      $("maxCard").value = "50";
      $("nEstimators").value = "100";
      $("maxFeatures").value = "1.0";
      $("maxDepth").value = "20";
      $("minNumSamples").value = "10";
      $("replacement").value = "false";
      $("taskMode").value = "auto";
      $("targetTransform").value = "none";
      $("splitMethod").value = "cutoff";
      $("splitStrategy").value = "random";
      $("predTopK").value = "30";
      $("predFilter").value = "";
      $("pageSize").value = "50";
      $("importanceMode").value = "base";
      if ($("predFullDetails")) $("predFullDetails").open = false;
      if ($("predInsightsDetails")) $("predInsightsDetails").open = false;
      $("pruneMinImp").value = "0.002";
      if ($("maxFeatures")) delete $("maxFeatures").dataset.userSet;
      if ($("maxDepth")) delete $("maxDepth").dataset.userSet;
      if ($("minNumSamples")) delete $("minNumSamples").dataset.userSet;

      if ($("advancedTargetDetails")) $("advancedTargetDetails").classList.add("hidden");
      if ($("multiClassSummaryCallout")) $("multiClassSummaryCallout").innerHTML = "";
      if ($("topNEnable")) $("topNEnable").checked = false;
      if ($("topNKeep")) $("topNKeep").value = "5";
      if ($("topNSummary")) $("topNSummary").textContent = "‚Äî";
      if ($("derivedTargetColName")) $("derivedTargetColName").value = "";
      if ($("derivedTargetColName")) delete $("derivedTargetColName").dataset.userSet;
      if ($("derivedTargetExpr")) $("derivedTargetExpr").value = "";
      if ($("derivedTargetExpr")) delete $("derivedTargetExpr").dataset.userSet;
      if ($("derivedTargetStatus")) $("derivedTargetStatus").textContent = "‚Äî";

      gotoStep(0);
    }

    function resetForNewFile() {
      const taskModeRaw = $("taskMode").value;
      const taskMode =
        (taskModeRaw === "auto" || taskModeRaw === "regression" || taskModeRaw === "classification")
          ? taskModeRaw
          : "auto";
      const prefs = {
        testFrac: parseNum($("testFrac").value) || 0.1,
        splitMethod: $("splitMethod").value || "cutoff",
        cutoffDate: $("cutoffDate").value || "",
        splitStrategy: $("splitStrategy").value || "random",
        taskMode,
        targetTransform: $("targetTransform").value,
        maxRows: Math.floor(parseNum($("maxRows").value) || 0),
        maxCard: Math.max(1, Math.floor(parseNum($("maxCard").value) || 50)),
        nEstimators: Math.max(10, Math.floor(parseNum($("nEstimators").value) || 100)),
        maxFeatures: $("maxFeatures").value || "1.0",
        maxDepth: $("maxDepth")?.value || "",
        minNumSamples: $("minNumSamples")?.value || "",
        replacement: $("replacement").value || "false",
        seed: $("seed").value,
      };

      hardReset();

      APP.setup.testFrac = Math.min(0.5, Math.max(0.05, prefs.testFrac));
      APP.setup.splitMethod = prefs.splitMethod;
      APP.setup.cutoffDate = prefs.cutoffDate;
      APP.setup.splitStrategy = prefs.splitStrategy;
      APP.setup.taskMode = prefs.taskMode;
      APP.setup.targetTransform = prefs.targetTransform;
      APP.setup.maxRows = Math.max(0, prefs.maxRows);
      APP.setup.maxCard = prefs.maxCard;
      APP.setup.excluded = new Set();
      APP.setup.forcedTypes = { date: new Set(), categorical: new Set(), continuous: new Set() };
      syncHiddenTypingLists();

      $("testFrac").value = String(APP.setup.testFrac);
      $("splitMethod").value = APP.setup.splitMethod;
      $("cutoffDate").value = APP.setup.cutoffDate;
      $("splitStrategy").value = APP.setup.splitStrategy;
      $("taskMode").value = taskMode;
      $("targetTransform").value = prefs.targetTransform;
      $("maxRows").value = String(APP.setup.maxRows);
      $("maxCard").value = String(APP.setup.maxCard);
      $("nEstimators").value = String(prefs.nEstimators);
      $("maxFeatures").value = String(prefs.maxFeatures);
      if ($("maxDepth")) $("maxDepth").value = String(prefs.maxDepth);
      if ($("minNumSamples")) $("minNumSamples").value = String(prefs.minNumSamples);
      $("replacement").value = String(prefs.replacement);
      $("seed").value = prefs.seed;
    }

    function handleParsed(rows, cols, fileName) {
      if (!rows.length || !cols.length) {
        $("uploadStatus").innerHTML = `<span class="pill bad">Parse failed</span><span class="muted2">No rows/columns found.</span>`;
        return;
      }

      APP.raw.fileName = fileName || "data.csv";
      APP.raw.rows = rows;
      APP.raw.columns = cols;
      APP.ui.maxUnlockedStep = Math.max(APP.ui.maxUnlockedStep || 0, 1);
      renderStepper();

      recomputeColumnMeta();

      $("dsLoadedPill").textContent = `Loaded: ${APP.raw.fileName}`;
      $("dsShapePill").textContent = `${rows.length} rows ¬∑ ${cols.length} cols`;

      APP.ui.previewFilter = "";
      renderPreviewTable(rows, cols);
      bindPreviewTargetPicker();

      hide($("dropZone"));
      show($("uploadSummary"));
      $("uploadStatus").innerHTML =
        `<span class="pill">Pick a target</span>` +
        `<span class="muted2">Pick the column you want to predict (click a header or use search).</span>`;

      $("targetSearch").value = "";

      $("continueToSetupBtn").disabled = false;

      APP.raw.targetCol = null;
      renderTargetSelect();
      refreshSplitDateCol();
      syncSetupUI();
      renderColumnTable();
      syncButtons();
    }

    function handleFile(file) {
      if (!file) return;

      const parseSeq = (APP.ui.parseSeq = (APP.ui.parseSeq || 0) + 1);
      $("uploadStatus").innerHTML = `<span class="spinner"></span><span class="muted2">Parsing <span class="mono">${escapeHtml(file.name)}</span>‚Ä¶</span>`;

      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        worker: true,
        complete: (res) => {
          if (parseSeq !== APP.ui.parseSeq) return;
          const rows = res.data || [];
          const cols = (res.meta && res.meta.fields) ? res.meta.fields.filter(Boolean) : [];
          handleParsed(rows, cols, file.name);
        },
        error: (err) => {
          if (parseSeq !== APP.ui.parseSeq) return;
          $("uploadStatus").innerHTML = `<span class="pill bad">Parse error</span><span class="mono">${escapeHtml(err?.message || String(err))}</span>`;
        }
      });
    }

    function sampleCsvText() {
      const rng = mulberry32(91173);
      const secret = mulberry32(63821);

      const productSizes = ["Compact", "Small", "Medium", "Large"];
      const states = ["CA", "TX", "WA", "NY", "FL", "IL", "CO", "GA"];

      const basePrice = 18000 + Math.round(secret() * 9000);
      const wYear = 650 + Math.round(secret() * 450);
      const wHours = -(1.4 + secret() * 1.3);
      const wSaleYear = 250 + Math.round(secret() * 250);
      const noiseScale = 900 + Math.round(secret() * 900);

      const sizeOffsets = productSizes
        .map(() => (secret() * 2 - 1))
        .sort((a, b) => a - b)
        .map((v) => Math.round(v * 4500));

      const lines = ["price,year_made,product_size,state,sale_date,machine_hours"];

      for (let i = 0; i < 1000; i++) {
        const saleYear = 2010 + Math.floor(rng() * 5);
        const saleMonth = 1 + Math.floor(rng() * 12);
        const saleDay = 1 + Math.floor(rng() * 28);
        const saleDate = `${saleYear}-${String(saleMonth).padStart(2, "0")}-${String(saleDay).padStart(2, "0")}`;

        const yearMade = 1990 + Math.floor(rng() * (saleYear - 1989));
        const machineHours = Math.round(200 + rng() * 11800);
        const productSize = productSizes[Math.floor(rng() * productSizes.length)];
        const state = states[Math.floor(rng() * states.length)];

        const centeredYear = yearMade - 2002;
        const centeredHours = machineHours - 6000;
        const centeredSaleYear = saleYear - 2012;
        const sizeOffset = sizeOffsets[productSizes.indexOf(productSize)];

        const u1 = Math.max(1e-12, rng());
        const u2 = Math.max(1e-12, rng());
        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);

        const priceRaw =
          basePrice +
          wYear * centeredYear +
          wHours * centeredHours +
          wSaleYear * centeredSaleYear +
          sizeOffset +
          z * noiseScale;

        const price = Math.max(500, Math.round(priceRaw / 10) * 10);
        lines.push(`${price},${yearMade},${productSize},${state},${saleDate},${machineHours}`);
      }

      return lines.join("\n");
    }

    function parseSampleCsvText(text) {
      APP.ui.parseSeq = (APP.ui.parseSeq || 0) + 1;
      const res = Papa.parse(text, { header: true, skipEmptyLines: true, dynamicTyping: false });
      const rows = res.data || [];
      const cols = (res.meta && res.meta.fields) ? res.meta.fields.filter(Boolean) : [];
      handleParsed(rows, cols, "sample.csv");
    }

    // ----------------------------
    // Events
    // ----------------------------
    $("hwBadge").textContent = `üß† CPU threads: ${navigator.hardwareConcurrency || "?"}`;
    $("resetAllBtn").addEventListener("click", hardReset);

    $("browseBtn").addEventListener("click", () => $("fileInput").click());
    $("fileInput").addEventListener("change", (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      resetForNewFile();
      handleFile(f);
    });

    $("sampleBtn").addEventListener("click", () => {
      resetForNewFile();
      parseSampleCsvText(sampleCsvText());
    });

    const dz = $("dropZone");
    dz.addEventListener("dragover", (e) => { e.preventDefault(); e.stopPropagation(); dz.classList.add("dragover"); });
    dz.addEventListener("dragleave", (e) => { e.stopPropagation(); dz.classList.remove("dragover"); });
    dz.addEventListener("drop", (e) => {
      e.preventDefault(); e.stopPropagation(); dz.classList.remove("dragover");
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      resetForNewFile();
      handleFile(f);
    });

    function isFileDragEvent(e) {
      const dt = e.dataTransfer;
      if (!dt) return false;
      if (dt.files && dt.files.length) return true;
      const types = dt.types ? Array.from(dt.types) : [];
      return types.includes("Files");
    }

    let globalDragDepth = 0;
    function setGlobalDropOverlayVisible(visible) {
      const el = $("globalDropOverlay");
      if (!el) return;
      if (visible) el.classList.remove("hidden");
      else el.classList.add("hidden");
    }

    window.addEventListener("dragenter", (e) => {
      if (!isFileDragEvent(e)) return;
      globalDragDepth += 1;
      setGlobalDropOverlayVisible(true);
    }, true);

    window.addEventListener("dragleave", (e) => {
      if (!globalDragDepth) return;
      globalDragDepth = Math.max(0, globalDragDepth - 1);
      if (!globalDragDepth) setGlobalDropOverlayVisible(false);
    }, true);

    window.addEventListener("dragover", (e) => {
      if (!isFileDragEvent(e)) return;
      e.preventDefault();
      if (e.dataTransfer) e.dataTransfer.dropEffect = "copy";
      setGlobalDropOverlayVisible(true);
    });

    window.addEventListener("drop", (e) => {
      if (!isFileDragEvent(e)) return;
      e.preventDefault();
      globalDragDepth = 0;
      setGlobalDropOverlayVisible(false);
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (!f) return;
      resetForNewFile();
      handleFile(f);
    });

    window.addEventListener("dragend", () => {
      globalDragDepth = 0;
      setGlobalDropOverlayVisible(false);
    });

    $("continueToSetupBtn").addEventListener("click", () => {
      renderTargetSelect();
      refreshSplitDateCol();
      syncSetupUI();
      renderColumnTable();
      gotoStep(1);
    });

    $("backToUploadBtn").addEventListener("click", () => gotoStep(0));
    $("continueToTrainBtn").addEventListener("click", () => gotoStep(2));
    $("backToSetupBtn").addEventListener("click", () => gotoStep(1));
    $("backToTrainBtn").addEventListener("click", () => gotoStep(2));
    $("jumpToExportBtn").addEventListener("click", () => gotoStep(4));
    $("backToResultsBtn").addEventListener("click", () => gotoStep(3));

    $("targetSelect").addEventListener("change", () => {
      APP.raw.targetCol = $("targetSelect").value;
      if (APP.raw.targetCol) APP.setup.excluded.delete(APP.raw.targetCol);
      if (APP.raw.targetCol) {
        APP.ui.maxUnlockedStep = Math.max(APP.ui.maxUnlockedStep || 0, 2);
        renderStepper();
      }
      recomputeColumnMeta();
      if (APP.raw.targetCol) {
        const taskModeRaw = $("taskMode")?.value || APP.setup.taskMode || "auto";
        const taskMode =
          (taskModeRaw === "auto" || taskModeRaw === "regression" || taskModeRaw === "classification")
            ? taskModeRaw
            : "auto";
        APP.setup.taskMode = taskMode;
        $("taskMode").value = taskMode;
      }
      applyAutoTrainDefaults();
      refreshSplitDateCol();
      syncSetupUI();
      renderColumnTable();
      syncButtons();
    });

    $("targetSearch").addEventListener("input", () => {
      APP.ui.previewFilter = $("targetSearch").value;
      renderPreviewTable(APP.raw.rows, APP.raw.columns);
    });

    $("taskMode").addEventListener("change", () => {
      APP.setup.taskMode = $("taskMode").value;
      syncSetupUI();
      renderTrainChips();
      applyAutoTrainDefaults();
    });

    $("targetTransform").addEventListener("change", () => {
      APP.setup.targetTransform = $("targetTransform").value;
      syncSetupUI();
    });

    $("maxRows").addEventListener("change", () => {
      APP.setup.maxRows = Math.floor(parseNum($("maxRows").value) || 0);
      syncSetupUI();
      applyAutoTrainDefaults();
    });

    $("splitStrategy").addEventListener("change", () => {
      APP.setup.splitStrategy = $("splitStrategy").value || "random";
      syncSetupUI();
      renderTrainChips();
    });

    $("splitDateCol").addEventListener("change", () => {
      APP.setup.splitDateCol = $("splitDateCol").value;
      syncSetupUI();
      renderTrainChips();
    });

    $("splitMethod").addEventListener("change", () => {
      APP.setup.splitMethod = $("splitMethod").value;
      syncSetupUI();
      renderTrainChips();
    });

    $("cutoffDate").addEventListener("change", () => {
      APP.setup.cutoffDate = $("cutoffDate").value || "";
      syncSetupUI();
      renderTrainChips();
    });

    $("testFrac").addEventListener("change", () => {
      APP.setup.testFrac = Math.min(0.5, Math.max(0.05, parseNum($("testFrac").value) || 0.1));
      syncSetupUI();
      renderTrainChips();
    });

    $("topNEnable").addEventListener("change", () => {
      APP.setup.multiClass.topN.enabled = Boolean($("topNEnable").checked);
      syncAdvancedTargetUI();
      renderTrainChips();
    });

    $("topNKeep").addEventListener("change", () => {
      const v = Math.max(1, Math.floor(parseNum($("topNKeep").value) || 1));
      APP.setup.multiClass.topN.keep = v;
      $("topNKeep").value = String(v);
      syncAdvancedTargetUI();
      renderTrainChips();
    });

    $("derivedTargetColName").addEventListener("input", () => {
      $("derivedTargetColName").dataset.userSet = "1";
      syncAdvancedTargetUI();
    });

    $("derivedTargetExpr").addEventListener("input", () => {
      $("derivedTargetExpr").dataset.userSet = "1";
      syncAdvancedTargetUI();
    });

    $("applyDerivedTargetBtn").addEventListener("click", () => {
      const dt = APP.setup.multiClass?.derivedTarget || null;
      if (dt) { dt.lastError = ""; dt.lastStatus = ""; }
      try {
        applyDerivedTargetFromExpr();
      } catch (e) {
        if (dt) dt.lastError = e?.message || String(e);
        syncAdvancedTargetUI();
      }
    });

    $("undoDerivedTargetBtn").addEventListener("click", () => {
      undoDerivedTarget();
      syncAdvancedTargetUI();
      renderTrainChips();
    });

    let typingDebounce = null;
    const scheduleTypingRefresh = () => {
      if (!APP.raw.columns.length) return;
      if (typingDebounce) clearTimeout(typingDebounce);
      typingDebounce = setTimeout(() => {
        recomputeColumnMeta();
        refreshSplitDateCol();
        syncSetupUI();
        applyAutoTrainDefaults();
        renderColumnTable();
        syncButtons();
      }, 80);
    };

    function markTrainSettingAsUserSet(id) {
      const el = $(id);
      if (!el) return;
      const mark = () => { el.dataset.userSet = "1"; };
      el.addEventListener("input", mark);
      el.addEventListener("change", mark);
    }
    markTrainSettingAsUserSet("maxFeatures");
    markTrainSettingAsUserSet("maxDepth");
    markTrainSettingAsUserSet("minNumSamples");
    markTrainSettingAsUserSet("derivedTargetColName");
    markTrainSettingAsUserSet("derivedTargetExpr");

    $("maxCard").addEventListener("input", scheduleTypingRefresh);
    $("reviewColumnsTable").querySelectorAll("th.sortable[data-sort]").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.getAttribute("data-sort");
        if (!key) return;
        if (APP.ui.colSort.key === key) APP.ui.colSort.dir = (APP.ui.colSort.dir === "asc") ? "desc" : "asc";
        else { APP.ui.colSort.key = key; APP.ui.colSort.dir = "asc"; }
        renderColumnTable();
      });
    });

    $("trainBtn").addEventListener("click", trainModel);
    $("stopBtn").addEventListener("click", requestStopTraining);

    window.addEventListener("pagehide", (e) => {
      if (e.persisted) return;
      releaseAllResources();
    });
    window.addEventListener("beforeunload", () => {
      releaseAllResources();
    });

    $("importanceMode").addEventListener("change", () => {
      if (!APP.train.model) return;
      const mode = $("importanceMode").value;
      if (mode === "derived") renderFIChart(APP.train.fiDerived, "importance", "derived");
      else renderFIChart(APP.train.fiBase, "importance", "base");
    });

    $("predFilter").addEventListener("input", () => { APP.ui.predPage = 0; renderPredTable(); });
    $("pageSize").addEventListener("change", () => { APP.ui.predPage = 0; renderPredTable(); });
    $("predTopK").addEventListener("change", () => { renderPredInsights(); });
    $("predInsightsDetails").addEventListener("toggle", () => {
      if ($("predInsightsDetails").open) {
        renderPredInsights();
        if (APP.ui.charts.errUnc) APP.ui.charts.errUnc.resize();
      }
    });

    $("pruneImpBtn").addEventListener("click", () => {
      if (!APP.train.model || !APP.train.pipeline) return;
      const included = currentIncludedFeatureCols();
      const fiNorm = normalizeFi(APP.train.fiBase).filter(x => included.includes(x.name));
      if (!fiNorm.length) return;

      const tau = Math.max(0, parseNum($("pruneMinImp").value) || 0);
      const keep = fiNorm.filter(x => x.frac >= tau).map(x => x.name);
      const minKeep = Math.min(included.length, 5);
      if (keep.length < minKeep) {
        keep.length = 0;
        for (let i = 0; i < Math.min(minKeep, fiNorm.length); i++) keep.push(fiNorm[i].name);
      }
      const drop = included.filter(c => !keep.includes(c));
      applyExclusionsAndRetrain({ dropCols: drop, reason: `Pruned low-importance (min imp=${formatNum(tau, 4)})` });
    });

    $("pruneShiftTopBtn").addEventListener("click", () => {
      if (!APP.train.model || !APP.train.pipeline) return;
      const shiftFi = APP.train.shift?.fiBase || null;
      const shiftScore = APP.train.shift?.oobBalAcc ?? APP.train.shift?.oobAcc ?? null;
      if (!Array.isArray(shiftFi) || !shiftFi.length || shiftScore === null) return;
      const included = currentIncludedFeatureCols();
      const fiNorm = normalizeFi(shiftFi).filter(x => included.includes(x.name));
      if (!fiNorm.length) return;
      const top = fiNorm[0].name;
      applyExclusionsAndRetrain({ dropCols: [top], reason: `Pruned top shift driver (${top})` });
    });

    $("pruneUndoBtn").addEventListener("click", () => {
      undoLastPrune();
    });

    $("prevPage").addEventListener("click", () => { APP.ui.predPage = Math.max(0, APP.ui.predPage - 1); renderPredTable(); });
    $("nextPage").addEventListener("click", () => { APP.ui.predPage = APP.ui.predPage + 1; renderPredTable(); });

    $("downloadPredCsvBtn").addEventListener("click", () => {
      if (!APP.train.model) return;
      const csv = buildPredictionsCsv();
      downloadBlob(new Blob([csv], { type: "text/csv;charset=utf-8" }), "test_predictions.csv");
    });

    $("downloadZipBtn").addEventListener("click", async () => {
      const artifact = buildArtifact();
      if (!artifact) return;

      const sample = $("sampleCode").textContent || "";
      const predCsv = APP.train.model ? buildPredictionsCsv() : "";

      const readme = `# Random Forest Artifact

This zip contains:
- rf_artifact.json: preprocessing pipeline + serialized ml-random-forest model
- use_model.js: sample loader code (browser ESM + Node)
- test_predictions.csv: your test split with predictions + uncertainty (tree disagreement)

Notes
- Preprocessing is fit on the training split only to avoid leakage.
- Categorical features are label-encoded. Missing/unknown -> id 0 ("#na#").
- Continuous features are median-imputed + "_na" missing-indicator columns.
- Date features are expanded into date parts + "_na".
- If you trained with targetTransform=log1p, predictions should be inverted with expm1.

Compatibility
- Serialization uses ml-random-forest@2.1.0
`;

      const zip = new JSZip();
      zip.file("rf_artifact.json", JSON.stringify(artifact, null, 2));
      zip.file("use_model.js", sample);
      zip.file("test_predictions.csv", predCsv);
      zip.file("README.md", readme);

      const blob = await zip.generateAsync({ type: "blob" });
      downloadBlob(blob, "rf_artifact.zip");
      showToast("Downloading rf_artifact.zip", "good");
    });

    // Keyboard: Return = "next step" (via training)
    window.addEventListener("keydown", (e) => {
      if (e.key !== "Enter") return;
      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) return;

      const ae = document.activeElement;
      if (ae && (ae.tagName === "TEXTAREA" || ae.isContentEditable)) return;
      if (APP.ui.training.isTraining) return;

      if (APP.step === 0) {
        if ($("continueToSetupBtn")?.disabled) return;
        e.preventDefault();
        gotoStep(1);
        return;
      }

      if (APP.step === 1) {
        if ($("continueToTrainBtn")?.disabled) return;
        e.preventDefault();
        gotoStep(2);
        return;
      }

      if (APP.step === 2) {
        if ($("trainBtn")?.disabled) return;
        e.preventDefault();
        trainModel();
        return;
      }

      if (APP.step === 3) {
        e.preventDefault();
        gotoStep(4);
        return;
      }

      if (APP.step === 4) {
        if ($("downloadZipBtn")?.disabled) return;
        e.preventDefault();
        $("downloadZipBtn").click();
      }
    });

    // ----------------------------
    // Init
    // ----------------------------
    renderStepper();

    hardReset();

    syncButtons();
  </script>
</body>
</html>
